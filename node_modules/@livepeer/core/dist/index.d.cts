type MimeType = keyof typeof mime;
declare const mime: {
    readonly "application/mp4": readonly ["mp4s", "m4p"];
    readonly "application/ogg": readonly ["ogx"];
    readonly "application/vnd.apple.mpegurl": readonly ["m3u8"];
    readonly "audio/3gpp": readonly ["*3gpp"];
    readonly "audio/adpcm": readonly ["adp"];
    readonly "audio/amr": readonly ["amr"];
    readonly "audio/basic": readonly ["au", "snd"];
    readonly "audio/midi": readonly ["mid", "midi", "kar", "rmi"];
    readonly "audio/mobile-xmf": readonly ["mxmf"];
    readonly "audio/mp3": readonly ["*mp3"];
    readonly "audio/mp4": readonly ["m4a", "mp4a"];
    readonly "audio/mpeg": readonly ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"];
    readonly "audio/ogg": readonly ["oga", "ogg", "spx", "opus"];
    readonly "audio/s3m": readonly ["s3m"];
    readonly "audio/silk": readonly ["sil"];
    readonly "audio/vnd.dece.audio": readonly ["uva", "uvva"];
    readonly "audio/vnd.digital-winds": readonly ["eol"];
    readonly "audio/vnd.dra": readonly ["dra"];
    readonly "audio/vnd.dts.hd": readonly ["dtshd"];
    readonly "audio/vnd.dts": readonly ["dts"];
    readonly "audio/vnd.lucent.voice": readonly ["lvp"];
    readonly "audio/vnd.ms-playready.media.pya": readonly ["pya"];
    readonly "audio/vnd.nuera.ecelp4800": readonly ["ecelp4800"];
    readonly "audio/vnd.nuera.ecelp7470": readonly ["ecelp7470"];
    readonly "audio/vnd.nuera.ecelp9600": readonly ["ecelp9600"];
    readonly "audio/vnd.rip": readonly ["rip"];
    readonly "audio/wav": readonly ["wav"];
    readonly "audio/wave": readonly ["*wav"];
    readonly "audio/webm": readonly ["weba"];
    readonly "audio/x-aac": readonly ["aac"];
    readonly "audio/x-aiff": readonly ["aif", "aiff", "aifc"];
    readonly "audio/x-caf": readonly ["caf"];
    readonly "audio/x-flac": readonly ["flac"];
    readonly "audio/x-m4a": readonly ["*m4a"];
    readonly "audio/x-matroska": readonly ["mka"];
    readonly "audio/x-mpegurl": readonly ["m3u"];
    readonly "audio/x-ms-wax": readonly ["wax"];
    readonly "audio/x-ms-wma": readonly ["wma"];
    readonly "audio/x-pn-realaudio-plugin": readonly ["rmp"];
    readonly "audio/x-pn-realaudio": readonly ["ram", "ra"];
    readonly "audio/x-realaudio": readonly ["*ra"];
    readonly "audio/x-wav": readonly ["*wav"];
    readonly "audio/xm": readonly ["xm"];
    readonly "video/3gpp": readonly ["3gp", "3gpp"];
    readonly "video/3gpp2": readonly ["3g2"];
    readonly "video/h261": readonly ["h261"];
    readonly "video/h263": readonly ["h263"];
    readonly "video/h264": readonly ["h264"];
    readonly "video/iso.segment": readonly ["m4s"];
    readonly "video/jpeg": readonly ["jpgv"];
    readonly "video/jpm": readonly ["*jpm", "jpgm"];
    readonly "video/mj2": readonly ["mj2", "mjp2"];
    readonly "video/mp2t": readonly ["ts"];
    readonly "video/mp4": readonly ["mp4", "mp4v", "mpg4"];
    readonly "video/mpeg": readonly ["mpeg", "mpg", "mpe", "m1v", "m2v"];
    readonly "video/ogg": readonly ["ogv"];
    readonly "video/quicktime": readonly ["qt", "mov"];
    readonly "video/vnd.dece.hd": readonly ["uvh", "uvvh"];
    readonly "video/vnd.dece.mobile": readonly ["uvm", "uvvm"];
    readonly "video/vnd.dece.pd": readonly ["uvp", "uvvp"];
    readonly "video/vnd.dece.sd": readonly ["uvs", "uvvs"];
    readonly "video/vnd.dece.video": readonly ["uvv", "uvvv"];
    readonly "video/vnd.dvb.file": readonly ["dvb"];
    readonly "video/vnd.fvt": readonly ["fvt"];
    readonly "video/vnd.mpegurl": readonly ["mxu", "m4u"];
    readonly "video/vnd.ms-playready.media.pyv": readonly ["pyv"];
    readonly "video/vnd.uvvu.mp4": readonly ["uvu", "uvvu"];
    readonly "video/vnd.vivo": readonly ["viv"];
    readonly "video/vp8": readonly ["vp8"];
    readonly "video/webm": readonly ["webm"];
    readonly "video/x-f4v": readonly ["f4v"];
    readonly "video/x-fli": readonly ["fli"];
    readonly "video/x-flv": readonly ["flv"];
    readonly "video/x-m4v": readonly ["m4v"];
    readonly "video/x-matroska": readonly ["mkv", "mk3d", "mks"];
    readonly "video/x-mng": readonly ["mng"];
    readonly "video/x-ms-asf": readonly ["asf", "asx"];
    readonly "video/x-ms-vob": readonly ["vob"];
    readonly "video/x-ms-wm": readonly ["wm"];
    readonly "video/x-ms-wmv": readonly ["wmv"];
    readonly "video/x-ms-wmx": readonly ["wmx"];
    readonly "video/x-ms-wvx": readonly ["wvx"];
    readonly "video/x-msvideo": readonly ["avi"];
    readonly "video/x-sgi-movie": readonly ["movie"];
    readonly "video/x-smv": readonly ["smv"];
};

type AudioExtension = "m4a" | "mp4a" | "mpga" | "mp2" | "mp2a" | "mp3" | "m2a" | "m3a" | "wav" | "weba" | "aac" | "oga" | "spx";
type VideoExtension = "mp4" | "ogv" | "webm" | "mov" | "m4v" | "avi" | "m3u8";
type HlsExtension = "m3u8";
type VideoTextTrackExtension = "vtt";
type OptionalQueryParams = `?${string}` | "";
type BaseSrc = {
    type: "audio" | "video" | "hls" | "webrtc" | "image" | "vtt";
    src: string;
    mime: MimeType | null;
    width: number | null;
    height: number | null;
};
interface AudioSrc extends BaseSrc {
    type: "audio";
    src: `${string}${AudioExtension}${OptionalQueryParams}`;
}
interface VideoSrc extends BaseSrc {
    type: "video";
    src: `${string}${VideoExtension}${OptionalQueryParams}`;
}
interface ImageSrc extends BaseSrc {
    type: "image";
    src: `${string}${OptionalQueryParams}`;
}
interface VideoTextTrackSrc extends BaseSrc {
    type: "vtt";
    src: `${string}${VideoTextTrackExtension}${OptionalQueryParams}`;
}
interface Base64Src extends BaseSrc {
    type: "video";
    src: `${string}`;
}
interface HlsSrc extends BaseSrc {
    type: "hls";
    src: `${string}${HlsExtension}${OptionalQueryParams}`;
}
interface WebRTCSrc extends BaseSrc {
    type: "webrtc";
    src: `${string}${OptionalQueryParams}`;
}
interface FlvSrc extends BaseSrc {
    type: "video";
    src: `${string}`;
}
type Src = AudioSrc | HlsSrc | FlvSrc | VideoSrc | Base64Src | WebRTCSrc | ImageSrc | VideoTextTrackSrc;

/**
 * Parses various types of playback information and converts them into an array of Src objects.
 *
 * This function is designed to handle multiple input types: Livepeer playback info, Cloudflare stream data, Mux URLs, `string[]`, and `string`.
 * It processes these inputs to extract or construct source objects and then transforms these into `Src` inputs.
 *
 * These include the video playback information, as well as supporting data like thumbnails and VTT files, which can be used by the Player.
 *
 * The input types and their processing are as follows:
 * - `LivepeerPlaybackInfo`: Extracts the 'source' array from its 'meta' property.
 * - `LivepeerSource` or `LivepeerSource[]`: Uses the source object(s) directly.
 * - `CloudflareStreamData`: Retrieves the stream data and constructs Source objects.
 * - `CloudflareUrlData`: Uses the URL data to create a Source object.
 * - `string[]`: Assumes each string as a URL and creates an array of Source objects.
 * - `string`: Assumes the string is a URL and creates a single Source object.
 *
 * @param {LivepeerPlaybackInfo | LivepeerSource | LivepeerSource[] | CloudflareStreamData | CloudflareUrlData | string[] | string | null | undefined} source - The playback information to be parsed.
 * It can be of type `LivepeerPlaybackInfo`, `LivepeerSource`, `LivepeerSource[]`, `CloudflareStreamData`, `CloudflareUrlData`, `string[]` of URLs, or a single URL.
 * @returns {Src[] | null} An array of `Src` objects derived from the provided playback information, or null if the input is invalid or empty.
 *
 * Each `Src` object may contain the following properties:
 * - `url`: The URL of the media source.
 * - `size`: The size of the media file (optional).
 * - `width`: The width of the media (optional).
 * - `height`: The height of the media (optional).
 * - `bitrate`: The bitrate of the media (optional).
 */
declare const getSrc: (source: LivepeerPlaybackInfo | LivepeerSource | LivepeerSource[] | CloudflareStreamData | CloudflareUrlData | string[] | string | null | undefined) => Src[] | null;
/**
 * Parses various types of ingest information and converts them into a WHIP URL.
 *
 * This function is designed to handle multiple input types: strings (assumed to be stream keys or URLs), Cloudflare stream data, Cloudflare URL data, or Livepeer stream data. It processes these inputs to either return the URL directly, construct a WHIP URL using the provided base URL, or extract the URL from object data.
 *
 * - If the input is a valid URL (starting with http/https), it returns the URL directly.
 * - If the input is a string not starting with http/https, it treats the string as a stream key and constructs a WHIP URL using the provided base URL from opts.
 * - For object inputs (`CloudflareStreamData`, `CloudflareUrlData`, or `LivepeerStream`), it attempts to extract the URL from the `url`, `webRTC.url`, or `streamKey` properties.
 *
 * @param {string | LivepeerStream | CloudflareStreamData | CloudflareUrlData | null | undefined} ingest - The ingest information to be parsed. It can be a stream key, URL, Cloudflare stream data, Cloudflare URL data, or Livepeer stream data.
 * @param {Object} [opts] - Optional parameters.
 * @param {string | null | undefined} [opts.baseUrl] - The base URL used to construct a WHIP URL when a stream key is provided. Defaults to "https://playback.livepeer.studio/webrtc".
 * @returns {string | null} A WHIP URL derived from the provided ingest information, or null if the input is invalid, empty, or the necessary information to construct a WHIP URL is not provided.
 */
declare const getIngest: (ingest: string | LivepeerStream | CloudflareStreamData | CloudflareUrlData | null | undefined, opts?: {
    baseUrl?: string | null | undefined;
}) => string | null;
/**
 * Phase of the asset storage
 */
declare enum LivepeerPhase {
    Waiting = "waiting",
    Processing = "processing",
    Ready = "ready",
    Failed = "failed",
    Reverted = "reverted"
}
interface LivepeerTasks {
    /**
     * ID of any currently running task that is exporting this
     *
     * @remarks
     * asset to IPFS.
     *
     */
    pending?: string;
    /**
     * ID of the last task to run successfully, that created
     *
     * @remarks
     * the currently saved data.
     *
     */
    last?: string;
    /**
     * ID of the last task to fail execution.
     */
    failed?: string;
}
interface LivepeerStorageStatus {
    /**
     * Phase of the asset storage
     */
    phase?: LivepeerPhase;
    /**
     * Current progress of the task updating the storage.
     */
    progress?: number;
    /**
     * Error message if the last storage changed failed.
     */
    errorMessage?: string;
    tasks?: LivepeerTasks;
}
/**
 * Video Metadata EIP-712 primaryType
 */
declare enum LivepeerPrimaryType {
    VideoAttestation = "VideoAttestation"
}
declare enum LivepeerName {
    VerifiableVideo = "Verifiable Video"
}
declare enum LivepeerVersion {
    One = "1"
}
/**
 * Video Metadata EIP-712 domain
 */
interface LivepeerDomain {
    name?: LivepeerName;
    version?: LivepeerVersion;
}
interface LivepeerAttestations {
    role?: string;
    address?: string;
}
/**
 * Video Metadata EIP-712 message content
 */
interface LivepeerMessage {
    video?: string;
    attestations?: LivepeerAttestations[];
    signer?: string;
    timestamp?: number;
}
declare enum LivepeerSignatureType {
    Eip712 = "eip712",
    Flow = "flow"
}
interface LivepeerAttestationIpfs {
    /**
     * CID of the file on IPFS
     */
    cid?: string;
    /**
     * URL with IPFS scheme for the file
     */
    url?: string;
    /**
     * URL to access file via HTTP through an IPFS gateway
     */
    gatewayUrl?: string;
    /**
     * Timestamp (in milliseconds) at which IPFS export task was updated
     *
     * @remarks
     *
     */
    updatedAt?: number;
}
interface LivepeerAttestationStorage {
    ipfs?: LivepeerAttestationIpfs;
    status?: LivepeerStorageStatus;
}
interface LivepeerAttestation {
    id?: string;
    /**
     * Video Metadata EIP-712 primaryType
     */
    primaryType?: LivepeerPrimaryType;
    /**
     * Video Metadata EIP-712 domain
     */
    domain?: LivepeerDomain;
    /**
     * Video Metadata EIP-712 message content
     */
    message?: LivepeerMessage;
    /**
     * Video Metadata EIP-712 message signature
     */
    signature?: string;
    /**
     * Timestamp (in milliseconds) at which the object was created
     */
    createdAt?: number;
    signatureType?: LivepeerSignatureType;
    storage?: LivepeerAttestationStorage;
}
declare enum LivepeerTypeT {
    Public = "public",
    Jwt = "jwt",
    Webhook = "webhook"
}
/**
 * Whether the playback policy for a asset or stream is public or signed
 */
interface LivepeerPlaybackPolicy {
    type?: LivepeerTypeT;
    /**
     * ID of the webhook to use for playback policy
     */
    webhookId?: string;
    /**
     * User-defined webhook context
     */
    webhookContext?: Record<string, any>;
}
declare enum LivepeerPlaybackInfoType {
    Live = "live",
    Vod = "vod",
    Recording = "recording"
}
interface LivepeerSource {
    hrn?: string;
    type?: string;
    url?: string;
    size?: number;
    width?: number;
    height?: number;
    bitrate?: number;
}
interface LivepeerMeta {
    live?: number;
    /**
     * Whether the playback policy for a asset or stream is public or signed
     */
    playbackPolicy?: LivepeerPlaybackPolicy;
    source?: LivepeerSource[];
    attestation?: LivepeerAttestation;
}
interface LivepeerPlaybackInfo {
    type?: LivepeerPlaybackInfoType;
    meta?: LivepeerMeta;
}
interface LivepeerStream {
    streamKey?: string;
}
type CloudflareStreamData = {
    webRTC?: CloudflareUrlData;
    webRTCPlayback?: CloudflareUrlData;
};
type CloudflareUrlData = {
    url?: string;
};

type Address = `0x${string}`;
type Hash = `0x${string}`;

export { type Address, type CloudflareStreamData, type CloudflareUrlData, type Hash, type LivepeerAttestation, type LivepeerAttestationIpfs, type LivepeerAttestationStorage, type LivepeerAttestations, type LivepeerDomain, type LivepeerMessage, type LivepeerMeta, LivepeerName, LivepeerPhase, type LivepeerPlaybackInfo, LivepeerPlaybackInfoType, type LivepeerPlaybackPolicy, LivepeerPrimaryType, LivepeerSignatureType, type LivepeerSource, type LivepeerStorageStatus, type LivepeerStream, type LivepeerTasks, LivepeerTypeT, LivepeerVersion, getIngest, getSrc };
