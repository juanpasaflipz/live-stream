import { StoreApi } from 'zustand/vanilla';

type MimeType = keyof typeof mime;
declare const mime: {
    readonly "application/mp4": readonly ["mp4s", "m4p"];
    readonly "application/ogg": readonly ["ogx"];
    readonly "application/vnd.apple.mpegurl": readonly ["m3u8"];
    readonly "audio/3gpp": readonly ["*3gpp"];
    readonly "audio/adpcm": readonly ["adp"];
    readonly "audio/amr": readonly ["amr"];
    readonly "audio/basic": readonly ["au", "snd"];
    readonly "audio/midi": readonly ["mid", "midi", "kar", "rmi"];
    readonly "audio/mobile-xmf": readonly ["mxmf"];
    readonly "audio/mp3": readonly ["*mp3"];
    readonly "audio/mp4": readonly ["m4a", "mp4a"];
    readonly "audio/mpeg": readonly ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"];
    readonly "audio/ogg": readonly ["oga", "ogg", "spx", "opus"];
    readonly "audio/s3m": readonly ["s3m"];
    readonly "audio/silk": readonly ["sil"];
    readonly "audio/vnd.dece.audio": readonly ["uva", "uvva"];
    readonly "audio/vnd.digital-winds": readonly ["eol"];
    readonly "audio/vnd.dra": readonly ["dra"];
    readonly "audio/vnd.dts.hd": readonly ["dtshd"];
    readonly "audio/vnd.dts": readonly ["dts"];
    readonly "audio/vnd.lucent.voice": readonly ["lvp"];
    readonly "audio/vnd.ms-playready.media.pya": readonly ["pya"];
    readonly "audio/vnd.nuera.ecelp4800": readonly ["ecelp4800"];
    readonly "audio/vnd.nuera.ecelp7470": readonly ["ecelp7470"];
    readonly "audio/vnd.nuera.ecelp9600": readonly ["ecelp9600"];
    readonly "audio/vnd.rip": readonly ["rip"];
    readonly "audio/wav": readonly ["wav"];
    readonly "audio/wave": readonly ["*wav"];
    readonly "audio/webm": readonly ["weba"];
    readonly "audio/x-aac": readonly ["aac"];
    readonly "audio/x-aiff": readonly ["aif", "aiff", "aifc"];
    readonly "audio/x-caf": readonly ["caf"];
    readonly "audio/x-flac": readonly ["flac"];
    readonly "audio/x-m4a": readonly ["*m4a"];
    readonly "audio/x-matroska": readonly ["mka"];
    readonly "audio/x-mpegurl": readonly ["m3u"];
    readonly "audio/x-ms-wax": readonly ["wax"];
    readonly "audio/x-ms-wma": readonly ["wma"];
    readonly "audio/x-pn-realaudio-plugin": readonly ["rmp"];
    readonly "audio/x-pn-realaudio": readonly ["ram", "ra"];
    readonly "audio/x-realaudio": readonly ["*ra"];
    readonly "audio/x-wav": readonly ["*wav"];
    readonly "audio/xm": readonly ["xm"];
    readonly "video/3gpp": readonly ["3gp", "3gpp"];
    readonly "video/3gpp2": readonly ["3g2"];
    readonly "video/h261": readonly ["h261"];
    readonly "video/h263": readonly ["h263"];
    readonly "video/h264": readonly ["h264"];
    readonly "video/iso.segment": readonly ["m4s"];
    readonly "video/jpeg": readonly ["jpgv"];
    readonly "video/jpm": readonly ["*jpm", "jpgm"];
    readonly "video/mj2": readonly ["mj2", "mjp2"];
    readonly "video/mp2t": readonly ["ts"];
    readonly "video/mp4": readonly ["mp4", "mp4v", "mpg4"];
    readonly "video/mpeg": readonly ["mpeg", "mpg", "mpe", "m1v", "m2v"];
    readonly "video/ogg": readonly ["ogv"];
    readonly "video/quicktime": readonly ["qt", "mov"];
    readonly "video/vnd.dece.hd": readonly ["uvh", "uvvh"];
    readonly "video/vnd.dece.mobile": readonly ["uvm", "uvvm"];
    readonly "video/vnd.dece.pd": readonly ["uvp", "uvvp"];
    readonly "video/vnd.dece.sd": readonly ["uvs", "uvvs"];
    readonly "video/vnd.dece.video": readonly ["uvv", "uvvv"];
    readonly "video/vnd.dvb.file": readonly ["dvb"];
    readonly "video/vnd.fvt": readonly ["fvt"];
    readonly "video/vnd.mpegurl": readonly ["mxu", "m4u"];
    readonly "video/vnd.ms-playready.media.pyv": readonly ["pyv"];
    readonly "video/vnd.uvvu.mp4": readonly ["uvu", "uvvu"];
    readonly "video/vnd.vivo": readonly ["viv"];
    readonly "video/vp8": readonly ["vp8"];
    readonly "video/webm": readonly ["webm"];
    readonly "video/x-f4v": readonly ["f4v"];
    readonly "video/x-fli": readonly ["fli"];
    readonly "video/x-flv": readonly ["flv"];
    readonly "video/x-m4v": readonly ["m4v"];
    readonly "video/x-matroska": readonly ["mkv", "mk3d", "mks"];
    readonly "video/x-mng": readonly ["mng"];
    readonly "video/x-ms-asf": readonly ["asf", "asx"];
    readonly "video/x-ms-vob": readonly ["vob"];
    readonly "video/x-ms-wm": readonly ["wm"];
    readonly "video/x-ms-wmv": readonly ["wmv"];
    readonly "video/x-ms-wmx": readonly ["wmx"];
    readonly "video/x-ms-wvx": readonly ["wvx"];
    readonly "video/x-msvideo": readonly ["avi"];
    readonly "video/x-sgi-movie": readonly ["movie"];
    readonly "video/x-smv": readonly ["smv"];
};

type AudioExtension = "m4a" | "mp4a" | "mpga" | "mp2" | "mp2a" | "mp3" | "m2a" | "m3a" | "wav" | "weba" | "aac" | "oga" | "spx";
type VideoExtension = "mp4" | "ogv" | "webm" | "mov" | "m4v" | "avi" | "m3u8";
type HlsExtension = "m3u8";
type VideoTextTrackExtension = "vtt";
type OptionalQueryParams = `?${string}` | "";
type BaseSrc = {
    type: "audio" | "video" | "hls" | "webrtc" | "image" | "vtt";
    src: string;
    mime: MimeType | null;
    width: number | null;
    height: number | null;
};
interface AudioSrc extends BaseSrc {
    type: "audio";
    src: `${string}${AudioExtension}${OptionalQueryParams}`;
}
interface VideoSrc extends BaseSrc {
    type: "video";
    src: `${string}${VideoExtension}${OptionalQueryParams}`;
}
interface ImageSrc extends BaseSrc {
    type: "image";
    src: `${string}${OptionalQueryParams}`;
}
interface VideoTextTrackSrc extends BaseSrc {
    type: "vtt";
    src: `${string}${VideoTextTrackExtension}${OptionalQueryParams}`;
}
interface Base64Src extends BaseSrc {
    type: "video";
    src: `${string}`;
}
interface HlsSrc extends BaseSrc {
    type: "hls";
    src: `${string}${HlsExtension}${OptionalQueryParams}`;
}
interface WebRTCSrc extends BaseSrc {
    type: "webrtc";
    src: `${string}${OptionalQueryParams}`;
}
interface FlvSrc extends BaseSrc {
    type: "video";
    src: `${string}`;
}
type Src = AudioSrc | HlsSrc | FlvSrc | VideoSrc | Base64Src | WebRTCSrc | ImageSrc | VideoTextTrackSrc;
type AccessControlParams = {
    jwt?: string | null;
    accessKey?: string | null;
};
type VideoQuality = "1080p" | "720p" | "480p" | "360p" | "240p" | "144p" | "auto";
/**
 * Represents a single track selector
 */
type SingleTrackSelector = 
/** Selects no tracks */
"none"
/** Selects all tracks */
 | "all"
/** Selects all tracks */
 | "*"
/** Specific track ID */
 | `${number}`
/** Highest bit rate */
 | "maxbps"
/** Lowest bit rate */
 | "minbps"
/** Specific bit rate */
 | `${number}bps`
/** Specific bit rate */
 | `${number}kbps`
/** Specific bit rate */
 | `${number}mbps`
/** Greater than specific bit rate */
 | `>${number}bps`
/** Greater than specific bit rate */
 | `>${number}kbps`
/** Greater than specific bit rate */
 | `>${number}mbps`
/** Less than specific bit rate */
 | `<${number}bps`
/** Less than specific bit rate */
 | `<${number}kbps`
/** Less than specific bit rate */
 | `<${number}mbps`
/** Max less than specific bit rate */
 | `max<${number}bps`
/** Max less than specific bit rate */
 | `max<${number}kbps`
/** Max less than specific bit rate */
 | `max<${number}mbps`;
/**
 * Represents a single audio track selector
 */
type SingleAudioTrackSelector = SingleTrackSelector
/** Channel count */
 | "surround"
/** Channel count */
 | "mono"
/** Channel count */
 | "stereo"
/** Channel count */
 | `${number}ch`;
/**
 * Represents a single video track selector
 */
type SingleVideoTrackSelector = SingleTrackSelector
/** Highest pixel surface area */
 | "maxres"
/** Lowest pixel surface area */
 | "minres"
/** Specific pixel surface area */
 | `${number}x${number}`
/** Closest to specific pixel surface area */
 | `~${number}x${number}`
/** Greater than pixel surface area */
 | `>${number}x${number}`
/** Less than pixel surface area */
 | `<${number}x${number}`
/** Resolution */
 | "720p"
/** Resolution */
 | "1080p"
/** Resolution */
 | "1440p"
/** Resolution */
 | "2k"
/** Resolution */
 | "4k"
/** Resolution */
 | "5k"
/** Resolution */
 | "8k";
/**
 * Generic track selector for a given type
 */
type TrackSelector<T extends string> = T
/** Union of selectors */
 | `${T},${T}`
/** Difference of selectors */
 | `${T},!${T}`
/** Intersection of selectors */
 | `${T},|${T}`;
type VideoTrackSelector = TrackSelector<SingleVideoTrackSelector>;
type AudioTrackSelector = TrackSelector<SingleAudioTrackSelector>;
declare const getMediaSourceType: (src: string | null, opts?: {
    sizing?: ElementSize;
}) => Src | null;

type ClientStorage = {
    getItem: <T>(key: string, defaultState?: T | null) => Promise<T | null>;
    setItem: <T>(key: string, value: T | null) => Promise<void>;
    removeItem: (key: string) => Promise<void>;
};

type InitialProps = {
    /**
     * An access key to be used for playback. This key grants permission to play access key protected media.
     */
    accessKey: string | null;
    /** The aspect ratio for the container element. Defines the width to height ratio of the player, like 16:9 or 4:3. */
    aspectRatio: number | null;
    /**
     * If `autoPlay` was passed in to the Player. Determines if the media should attempt to start playing automatically on load.
     *
     * Autoplay for videos in modern browsers typically works only if the video is muted or if the user has previously interacted with the website.
     *
     * @link https://developer.chrome.com/blog/autoplay/
     */
    autoPlay: boolean;
    /**
     * Controls the initial value for exponential backoff, in ms. Defaults to 500ms, which is subsequently multiplied by 2^n power on each error.
     *
     * This is limited at a minimum of 100ms.
     */
    backoff: number;
    /**
     * Controls the maximum backoff when an error is encountered, in ms. Defaults to 30s.
     *
     * This is limited at a minimum of 10s, to prevent DDoS when a popular stream goes down.
     */
    backoffMax: number;
    /**
     * The length of the clip. This is usually used alongside `ClipTrigger`. Specifies the duration of the media clip, in seconds.
     *
     * Set to `null` to disable the ClipTrigger.
     */
    clipLength: ClipLength | null;
    /**
     * Whether hotkeys are enabled. Defaults to `true`. Allows users to use keyboard shortcuts for player control.
     *
     * This is highly recommended to adhere to ARIA guidelines.
     */
    hotkeys: boolean | "broadcast";
    /**
     * The JWT (JSON Web Token) which is passed along to allow playback of an asset. Used for authentication and information exchange.
     */
    jwt: string | null;
    /**
     * Whether low latency is enabled for live-streaming. `force` can be used to require low latency playback using WebRTC, with no fallback to HLS. Defaults to `true`,
     * which means that WebRTC is enabled by default, with fallback to HLS.
     */
    lowLatency: boolean | "force";
    /**
     * Callback called when there is an error. When `null` is passed, it indicates that the error has been resolved.
     */
    onError: ((error: PlaybackError | null) => void) | null;
    /**
     * The default playback rate for the media. Determines the speed at which the media is played, e.g. 0.5 for half-speed, 2 for double speed.
     *
     * This can be overridden during playback by the user with `RateSelect`.
     *
     * `constant` means the speed of live stream playback will remain consistent, instead of speeding up to catch up with the head of the stream.
     */
    playbackRate: PlaybackRate;
    /**
     * Controls how often the poster image updates when playing back a livestream, in ms. Set to `0` to disable. Defaults to 30s.
     */
    posterLiveUpdate: number;
    /**
     * The preload option passed in to the Player. Specifies how the media should be preloaded: 'auto', 'metadata', or 'none'.
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video
     */
    preload: "auto" | "metadata" | "none";
    /**
     * The timeout for playback before falling back to the next source. This includes SDP negotiation for WebRTC, waiting for WebRTC to play,
     * and responses from the server.
     *
     * In milliseconds - defaults to 10000.
     */
    timeout: number;
    /**
     * The storage option for saving persistent state, like volume and video quality.
     *
     * Defaults to `localStorage` in the browser. Pass `null` to disable storage.
     */
    storage: ClientStorage | null;
    /**
     * The default video quality for playback.
     *
     * This is overridden when a user changes it, and their preferences are, by default, saved to storage.
     */
    videoQuality: VideoQuality;
    /**
     * The default volume level of the media, ranging from 0 (muted) to 1 (maximum volume).
     *
     * This is overridden when a user changes it, and their preferences are, by default, saved to storage.
     */
    volume: number;
    /**
     * The viewerId for the viewer. A unique identifier for the user or session watching the media.
     */
    viewerId: string | null;
};
type DeviceInformation = {
    version: string;
    isMobile: boolean;
    isIos: boolean;
    isAndroid: boolean;
    userAgent: string;
    screenWidth: number | null;
    /** If the media supports changing the volume */
    isVolumeChangeSupported: boolean;
    /** If the media supports PiP */
    isPictureInPictureSupported: boolean;
    /** If the media supports fullscreen */
    isFullscreenSupported: boolean;
    /** If the media supports HLS playback */
    isHlsSupported: boolean;
    /** If the media supports WebRTC */
    isWebRTCSupported: boolean;
};
type ClipParams = {
    startTime: number;
    endTime: number;
};
type ControlsState = {
    /** The last time that play/pause was requested */
    requestedPlayPauseLastTime: number;
    /** The last time that fullscreen was changed */
    requestedFullscreenLastTime: number;
    /** The last time that picture in picture was changed */
    requestedPictureInPictureLastTime: number;
    /** The last time that the element was measured */
    requestedMeasureLastTime: number;
    /** Internal value when a user requests an update to the progress of the media */
    requestedRangeToSeekTo: number;
    /** The params for the latest clip request. */
    requestedClipParams: ClipParams | null;
    /** The parsed thumbnail URL for the media. */
    thumbnail: ImageSrc | null;
    /** The last time that a play event was received */
    playLastTime: number;
    /** The offset of the browser's livestream versus the server time (in ms). */
    playbackOffsetMs: number | null;
    /** The last time that the media was interacted with */
    lastInteraction: number;
    /** The parsed playbackId from the src */
    playbackId: string | null;
    /** The last time that an error occurred */
    lastError: number;
    /** Media sizing information */
    size: MediaSizing | null;
    /** If the volume is muted */
    muted: boolean;
    /** The volume, doesn't change when muted */
    volume: number;
    /** Session token for the current playback */
    sessionToken: string;
    /**
     * Configures the HLS options, for advanced usage of the Player.
     */
    hlsConfig: any | null;
    /**
     * Auto-hide controls after a set amount of time (in milliseconds).
     *
     * Defaults to 3000. Set to 0 for no hiding.
     */
    autohide: number;
};
type ObjectFit = "cover" | "contain";
type PlaybackError = {
    type: "offline" | "access-control" | "fallback" | "permissions" | "unknown";
    message: string;
};
type MediaSizing = {
    container?: ElementSize;
    media?: ElementSize;
    window?: ElementSize;
};
type ElementSize = {
    width: number;
    height: number;
};
type Metadata = {
    bframes?: number;
    bufferWindow?: number;
};
type ClipLength = 90 | 60 | 45 | 30 | 15 | 10;
/**
 * The playback rate. `constant` means playing WebRTC playback at a constant pace and not speeding up.
 */
type PlaybackRate = number | "constant";
type AriaText = {
    progress: string;
    pictureInPicture: string;
    fullscreen: string;
    playPause: string;
    clip: string | null;
    time: string;
};
type MediaControllerState = {
    /** The ARIA text for the current state */
    aria: AriaText;
    /** Current buffered end time for the media (in seconds) */
    buffered: number;
    /** Current buffered percent */
    bufferedPercent: number;
    /** If the media has loaded and can be played */
    canPlay: boolean;
    /** The current source that is playing. */
    currentSource: Src | null;
    /** The final playback URL for the media that is playing, after redirects. */
    currentUrl: string | null;
    /** Current total duration of the media (in seconds) */
    duration: number;
    /** If the media has experienced an error. */
    error: PlaybackError | null;
    /** The number of errors that have occurred. */
    errorCount: number;
    /** If the media is currently stalled */
    stalled: boolean;
    /** If the media is fullscreen. */
    fullscreen: boolean;
    /** If the media has been played yet */
    hasPlayed: boolean;
    /** If all controls are currently hidden */
    hidden: boolean;
    /** If the content is live media */
    live: boolean;
    /** If the media is currently loading */
    loading: boolean;
    /** If the video element is mounted on the DOM - this is used for initialization logic */
    mounted: boolean;
    /** The current playback rate for the media. Defaults to 1. */
    playbackRate: PlaybackRate;
    /** If the media is in picture in picture mode */
    pictureInPicture: boolean;
    /** The poster image URL for the media. */
    poster: string | null;
    /** Current progress of the media (in seconds) */
    progress: number;
    /** If the media is current playing or paused */
    playing: boolean;
    /** The sorted sources that were passed in to the Player */
    sortedSources: Src[] | string | null;
    /** Current volume of the media. 0 if it is muted. */
    volume: number;
    /** If the media is currently waiting for data */
    waiting: boolean;
    /** The quality of the video playback. */
    videoQuality: VideoQuality;
    /** If the media has ended */
    ended: boolean;
    __controls: ControlsState;
    __controlsFunctions: {
        setHidden: (hidden: boolean) => void;
        onCanPlay: () => void;
        onDurationChange: (duration: number) => void;
        onEnded: () => void;
        onError: (error: Error | null) => void;
        onFinalUrl: (url: string | null) => void;
        onLoading: () => void;
        onPause: () => void;
        onPlay: () => void;
        onProgress: (time: number) => void;
        onStalled: () => void;
        onWaiting: () => void;
        requestClip: () => void;
        requestMeasure: () => void;
        requestSeek: (time: number) => void;
        requestSeekBack: (difference?: number) => void;
        requestSeekDiff: (difference: number) => void;
        requestSeekForward: (difference?: number) => void;
        requestToggleFullscreen: () => void;
        requestToggleMute: (forceValue?: boolean) => void;
        requestTogglePictureInPicture: () => void;
        requestVolume: (volume: number) => void;
        setAutohide: (autohide: number) => void;
        setFullscreen: (fullscreen: boolean) => void;
        setHlsConfig: (hlsConfig: any) => void;
        setLive: (live: boolean) => void;
        setMounted: () => void;
        setPictureInPicture: (pictureInPicture: boolean) => void;
        setPlaybackRate: (rate: number | string) => void;
        setPoster: (poster: string | null) => void;
        setVideoQuality: (videoQuality: VideoQuality) => void;
        setSize: (size: Partial<MediaSizing>) => void;
        setVolume: (volume: number) => void;
        setWebsocketMetadata: (metadata: Metadata) => void;
        togglePlay: (force?: boolean) => void;
        updateBuffered: (buffered: number) => void;
        updateLastInteraction: () => void;
        updatePlaybackOffsetMs: (offset: number) => void;
    };
    /** The device information and support. */
    __device: DeviceInformation;
    /** The initial props passed into the component. */
    __initialProps: InitialProps;
    __metadata: Metadata | null;
};
type MediaControllerStore = StoreApi<MediaControllerState> & {
    subscribe: {
        (listener: (selectedState: MediaControllerState, previousSelectedState: MediaControllerState) => void): () => void;
        <U>(selector: (state: MediaControllerState) => U, listener: (selectedState: U, previousSelectedState: U) => void, options?: {
            equalityFn?: (a: U, b: U) => boolean;
            fireImmediately?: boolean;
        }): () => void;
    };
    persist: {
        onFinishHydration: (fn: (state: MediaControllerState) => void) => () => void;
    };
};
declare const createControllerStore: ({ device, storage, src, initialProps, playbackId, }: {
    device: DeviceInformation;
    storage: ClientStorage;
    src: Src[] | string | null;
    initialProps: Partial<InitialProps>;
    playbackId?: string | undefined;
}) => {
    store: MediaControllerStore;
    destroy: () => void;
};

type MetricsOpts = {
    /**
     * Disables the `progress` event listener, which is used to monitor when media is in a "playing" state.
     */
    disableProgressListener?: boolean;
};
type RawMetrics = {
    preloadTime: number | null;
    ttff: number | null;
    firstPlayback: number | null;
    nWaiting: number | null;
    timeWaiting: number;
    nStalled: number | null;
    timeStalled: number;
    timeUnpaused: number;
    nError: number | null;
    lastError?: string;
    videoHeight: number | null;
    videoWidth: number | null;
    playerHeight: number | null;
    playerWidth: number | null;
    playbackScore: number | null;
    player: `${"audio" | "hls" | "video" | "webrtc" | "image" | "vtt" | "unknown"}-${string}`;
    sourceType: MimeType | "unknown";
    offset: number | null;
    pageUrl: string;
    sourceUrl: string | null;
    duration: number | null;
    autoplay: "autoplay" | "preload-full" | "preload-metadata" | "standard";
    userAgent: string;
    uid: string;
};
type PlaybackRecord = {
    clockTime: number;
    mediaTime: number;
    score: number;
};
declare class PlaybackMonitor {
    active: boolean;
    values: PlaybackRecord[];
    score: number | null;
    averagingSteps: number;
    store: MediaControllerStore;
    constructor(store: MediaControllerStore);
    init(): void;
    reset(): void;
    destroy(): void;
    calculateScore(): number | null;
    valueToScore(a: PlaybackRecord, b?: PlaybackRecord): number;
}
declare class Timer {
    totalTime: number;
    countStarts: number;
    startTime: number;
    start(): void;
    stop(): void;
    getTotalTime(): number;
    getCountStarts(): number;
}
declare class MetricsStatus {
    requestedPlayTime: number | null;
    firstFrameTime: number | null;
    bootMs: number;
    retryCount: number;
    connected: boolean;
    store: MediaControllerStore;
    destroy: () => void;
    currentMetrics: RawMetrics;
    previousMetrics: RawMetrics | null;
    timeWaiting: Timer;
    timeStalled: Timer;
    timeUnpaused: Timer;
    constructor(store: MediaControllerStore, bootMs: number, opts: MetricsOpts | undefined);
    addError(error: string): void;
    getFirstPlayback(): number | null;
    setFirstPlayback(): void;
    getFirstFrameTime(): number | null;
    setFirstFrameTime(): void;
    setPlaybackScore(playbackScore: number): void;
    setConnected(isConnected: boolean): void;
    getMetrics(): {
        current: RawMetrics;
        previous: RawMetrics | null;
    };
}
type MediaMetrics = {
    metrics: MetricsStatus | null;
    destroy: () => void;
};
/**
 * Gather playback metrics from a media store and
 * report them to a websocket. Automatically handles a redirect to get the
 * metrics endpoint.
 *
 * @param store Element to capture playback metrics from
 */
declare function addMediaMetricsToStore(store: MediaControllerStore | undefined | null, opts?: MetricsOpts): MediaMetrics;

declare const getBoundedVolume: (volume: number) => number;
declare function calculateVideoQualityDimensions(videoQuality: VideoQuality, aspectRatio: InitialProps["aspectRatio"]): {
    width: number | null;
    height: number | null;
};

export { type AccessControlParams, type AriaText, type AudioSrc, type AudioTrackSelector, type Base64Src, type ClipLength, type ClipParams, type ControlsState, type DeviceInformation, type ElementSize, type HlsSrc, type InitialProps, type MediaControllerState, type MediaControllerStore, type MediaMetrics, type MediaSizing, type Metadata, MetricsStatus, type ObjectFit, type PlaybackError, PlaybackMonitor, type PlaybackRate, type SingleAudioTrackSelector, type SingleTrackSelector, type SingleVideoTrackSelector, type Src, type VideoQuality, type VideoSrc, type VideoTrackSelector, type WebRTCSrc, addMediaMetricsToStore, calculateVideoQualityDimensions, createControllerStore, getBoundedVolume, getMediaSourceType };
