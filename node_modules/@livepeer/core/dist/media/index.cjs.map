{"version":3,"sources":["../../src/media.ts","../../src/media/controller.ts","../../src/media/errors.ts","../../src/media/metrics-utils.ts","../../src/media/mime.ts","../../src/media/src.ts","../../src/media/utils.ts","../../src/media/metrics.ts"],"sourcesContent":["export { createControllerStore } from \"./media/controller\";\nexport type {\n  AriaText,\n  ClipLength,\n  ClipParams,\n  ControlsState,\n  DeviceInformation,\n  ElementSize,\n  InitialProps,\n  MediaControllerState,\n  MediaControllerStore,\n  MediaSizing,\n  Metadata,\n  ObjectFit,\n  PlaybackError,\n  PlaybackRate,\n} from \"./media/controller\";\nexport { addMediaMetricsToStore } from \"./media/metrics\";\nexport type {\n  MediaMetrics,\n  MetricsStatus,\n  PlaybackMonitor,\n} from \"./media/metrics\";\nexport { getMediaSourceType } from \"./media/src\";\nexport type {\n  AccessControlParams,\n  AudioSrc,\n  AudioTrackSelector,\n  Base64Src,\n  HlsSrc,\n  SingleAudioTrackSelector,\n  SingleTrackSelector,\n  SingleVideoTrackSelector,\n  Src,\n  VideoQuality,\n  VideoSrc,\n  VideoTrackSelector,\n  WebRTCSrc,\n} from \"./media/src\";\nexport {\n  calculateVideoQualityDimensions,\n  getBoundedVolume,\n} from \"./media/utils\";\n","import {\n  createJSONStorage,\n  persist,\n  subscribeWithSelector,\n} from \"zustand/middleware\";\nimport { type StoreApi, createStore } from \"zustand/vanilla\";\n\nimport type { ImageSrc, Src, VideoQuality } from \"./src\";\n\nimport {\n  isAccessControlError,\n  isBframesError,\n  isNotAcceptableError,\n  isPermissionsError,\n  isStreamOfflineError,\n} from \"./errors\";\nimport type { ClientStorage } from \"./storage\";\nimport {\n  generateRandomToken,\n  getBoundedRate,\n  getBoundedSeek,\n  getBoundedVolume,\n  getClipParams,\n  getFilteredNaN,\n  getNewSource,\n  getProgressAria,\n  parseCurrentSourceAndPlaybackId,\n} from \"./utils\";\n\nconst DEFAULT_AUTOHIDE_TIME = 3000; // milliseconds to wait before hiding controls\nconst DEFAULT_SEEK_TIME = 5000; // milliseconds which the media will skip when seeking with arrows/buttons\nconst DEFAULT_VOLUME_LEVEL = 1; // 0-1 for how loud the audio is\n\nexport type InitialProps = {\n  /**\n   * An access key to be used for playback. This key grants permission to play access key protected media.\n   */\n  accessKey: string | null;\n\n  /** The aspect ratio for the container element. Defines the width to height ratio of the player, like 16:9 or 4:3. */\n  aspectRatio: number | null;\n\n  /**\n   * If `autoPlay` was passed in to the Player. Determines if the media should attempt to start playing automatically on load.\n   *\n   * Autoplay for videos in modern browsers typically works only if the video is muted or if the user has previously interacted with the website.\n   *\n   * @link https://developer.chrome.com/blog/autoplay/\n   */\n  autoPlay: boolean;\n\n  /**\n   * Controls the initial value for exponential backoff, in ms. Defaults to 500ms, which is subsequently multiplied by 2^n power on each error.\n   *\n   * This is limited at a minimum of 100ms.\n   */\n  backoff: number;\n\n  /**\n   * Controls the maximum backoff when an error is encountered, in ms. Defaults to 30s.\n   *\n   * This is limited at a minimum of 10s, to prevent DDoS when a popular stream goes down.\n   */\n  backoffMax: number;\n\n  /**\n   * The length of the clip. This is usually used alongside `ClipTrigger`. Specifies the duration of the media clip, in seconds.\n   *\n   * Set to `null` to disable the ClipTrigger.\n   */\n  clipLength: ClipLength | null;\n\n  /**\n   * Whether hotkeys are enabled. Defaults to `true`. Allows users to use keyboard shortcuts for player control.\n   *\n   * This is highly recommended to adhere to ARIA guidelines.\n   */\n  hotkeys: boolean | \"broadcast\";\n\n  /**\n   * The JWT (JSON Web Token) which is passed along to allow playback of an asset. Used for authentication and information exchange.\n   */\n  jwt: string | null;\n\n  /**\n   * Whether low latency is enabled for live-streaming. `force` can be used to require low latency playback using WebRTC, with no fallback to HLS. Defaults to `true`,\n   * which means that WebRTC is enabled by default, with fallback to HLS.\n   */\n  lowLatency: boolean | \"force\";\n\n  /**\n   * Callback called when there is an error. When `null` is passed, it indicates that the error has been resolved.\n   */\n  onError: ((error: PlaybackError | null) => void) | null;\n\n  /**\n   * The default playback rate for the media. Determines the speed at which the media is played, e.g. 0.5 for half-speed, 2 for double speed.\n   *\n   * This can be overridden during playback by the user with `RateSelect`.\n   *\n   * `constant` means the speed of live stream playback will remain consistent, instead of speeding up to catch up with the head of the stream.\n   */\n  playbackRate: PlaybackRate;\n\n  /**\n   * Controls how often the poster image updates when playing back a livestream, in ms. Set to `0` to disable. Defaults to 30s.\n   */\n  posterLiveUpdate: number;\n\n  /**\n   * The preload option passed in to the Player. Specifies how the media should be preloaded: 'auto', 'metadata', or 'none'.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video\n   */\n  preload: \"auto\" | \"metadata\" | \"none\";\n\n  /**\n   * The timeout for playback before falling back to the next source. This includes SDP negotiation for WebRTC, waiting for WebRTC to play,\n   * and responses from the server.\n   *\n   * In milliseconds - defaults to 10000.\n   */\n  timeout: number;\n\n  /**\n   * The storage option for saving persistent state, like volume and video quality.\n   *\n   * Defaults to `localStorage` in the browser. Pass `null` to disable storage.\n   */\n  storage: ClientStorage | null;\n\n  /**\n   * The default video quality for playback.\n   *\n   * This is overridden when a user changes it, and their preferences are, by default, saved to storage.\n   */\n  videoQuality: VideoQuality;\n\n  /**\n   * The default volume level of the media, ranging from 0 (muted) to 1 (maximum volume).\n   *\n   * This is overridden when a user changes it, and their preferences are, by default, saved to storage.\n   */\n  volume: number;\n\n  /**\n   * The viewerId for the viewer. A unique identifier for the user or session watching the media.\n   */\n  viewerId: string | null;\n};\n\nexport type DeviceInformation = {\n  version: string;\n  isMobile: boolean;\n  isIos: boolean;\n  isAndroid: boolean;\n  userAgent: string;\n  screenWidth: number | null;\n\n  /** If the media supports changing the volume */\n  isVolumeChangeSupported: boolean;\n  /** If the media supports PiP */\n  isPictureInPictureSupported: boolean;\n  /** If the media supports fullscreen */\n  isFullscreenSupported: boolean;\n\n  /** If the media supports HLS playback */\n  isHlsSupported: boolean;\n  /** If the media supports WebRTC */\n  isWebRTCSupported: boolean;\n};\n\nexport type ClipParams = {\n  startTime: number;\n  endTime: number;\n};\n\nexport type ControlsState = {\n  /** The last time that play/pause was requested */\n  requestedPlayPauseLastTime: number;\n  /** The last time that fullscreen was changed */\n  requestedFullscreenLastTime: number;\n  /** The last time that picture in picture was changed */\n  requestedPictureInPictureLastTime: number;\n  /** The last time that the element was measured */\n  requestedMeasureLastTime: number;\n  /** Internal value when a user requests an update to the progress of the media */\n  requestedRangeToSeekTo: number;\n  /** The params for the latest clip request. */\n  requestedClipParams: ClipParams | null;\n\n  /** The parsed thumbnail URL for the media. */\n  thumbnail: ImageSrc | null;\n\n  /** The last time that a play event was received */\n  playLastTime: number;\n  /** The offset of the browser's livestream versus the server time (in ms). */\n  playbackOffsetMs: number | null;\n  /** The last time that the media was interacted with */\n  lastInteraction: number;\n  /** The parsed playbackId from the src */\n  playbackId: string | null;\n  /** The last time that an error occurred */\n  lastError: number;\n\n  /** Media sizing information */\n  size: MediaSizing | null;\n\n  /** If the volume is muted */\n  muted: boolean;\n  /** The volume, doesn't change when muted */\n  volume: number;\n\n  /** Session token for the current playback */\n  sessionToken: string;\n\n  /**\n   * Configures the HLS options, for advanced usage of the Player.\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: we use any here because of the lack of dependency on HLS.js\n  hlsConfig: any | null;\n\n  /**\n   * Auto-hide controls after a set amount of time (in milliseconds).\n   *\n   * Defaults to 3000. Set to 0 for no hiding.\n   */\n  autohide: number;\n};\n\nexport type ObjectFit = \"cover\" | \"contain\";\n\nexport type PlaybackError = {\n  type: \"offline\" | \"access-control\" | \"fallback\" | \"permissions\" | \"unknown\";\n  message: string;\n};\n\nexport type MediaSizing = {\n  container?: ElementSize;\n  media?: ElementSize;\n  window?: ElementSize;\n};\n\nexport type ElementSize = {\n  width: number;\n  height: number;\n};\n\nexport type Metadata = {\n  bframes?: number;\n  bufferWindow?: number;\n};\n\nexport type ClipLength = 90 | 60 | 45 | 30 | 15 | 10;\n\n/**\n * The playback rate. `constant` means playing WebRTC playback at a constant pace and not speeding up.\n */\nexport type PlaybackRate = number | \"constant\";\n\nexport type AriaText = {\n  progress: string;\n  pictureInPicture: string;\n  fullscreen: string;\n  playPause: string;\n  clip: string | null;\n  time: string;\n};\n\nexport type MediaControllerState = {\n  /** The ARIA text for the current state */\n  aria: AriaText;\n\n  /** Current buffered end time for the media (in seconds) */\n  buffered: number;\n  /** Current buffered percent */\n  bufferedPercent: number;\n\n  /** If the media has loaded and can be played */\n  canPlay: boolean;\n\n  /** The current source that is playing. */\n  currentSource: Src | null;\n  /** The final playback URL for the media that is playing, after redirects. */\n  currentUrl: string | null;\n\n  /** Current total duration of the media (in seconds) */\n  duration: number;\n\n  /** If the media has experienced an error. */\n  error: PlaybackError | null;\n  /** The number of errors that have occurred. */\n  errorCount: number;\n\n  /** If the media is currently stalled */\n  stalled: boolean;\n  /** If the media is fullscreen. */\n  fullscreen: boolean;\n\n  /** If the media has been played yet */\n  hasPlayed: boolean;\n\n  /** If all controls are currently hidden */\n  hidden: boolean;\n\n  /** If the content is live media */\n  live: boolean;\n\n  /** If the media is currently loading */\n  loading: boolean;\n\n  /** If the video element is mounted on the DOM - this is used for initialization logic */\n  mounted: boolean;\n\n  /** The current playback rate for the media. Defaults to 1. */\n  playbackRate: PlaybackRate;\n\n  /** If the media is in picture in picture mode */\n  pictureInPicture: boolean;\n\n  /** The poster image URL for the media. */\n  poster: string | null;\n\n  /** Current progress of the media (in seconds) */\n  progress: number;\n\n  /** If the media is current playing or paused */\n  playing: boolean;\n\n  /** The sorted sources that were passed in to the Player */\n  sortedSources: Src[] | string | null;\n\n  /** Current volume of the media. 0 if it is muted. */\n  volume: number;\n\n  /** If the media is currently waiting for data */\n  waiting: boolean;\n\n  /** The quality of the video playback. */\n  videoQuality: VideoQuality;\n\n  /** If the media has ended */\n  ended: boolean;\n\n  __controls: ControlsState;\n  __controlsFunctions: {\n    setHidden: (hidden: boolean) => void;\n    onCanPlay: () => void;\n    onDurationChange: (duration: number) => void;\n    onEnded: () => void;\n    onError: (error: Error | null) => void;\n    onFinalUrl: (url: string | null) => void;\n    onLoading: () => void;\n    onPause: () => void;\n    onPlay: () => void;\n    onProgress: (time: number) => void;\n    onStalled: () => void;\n    onWaiting: () => void;\n    requestClip: () => void;\n    requestMeasure: () => void;\n    requestSeek: (time: number) => void;\n    requestSeekBack: (difference?: number) => void;\n    requestSeekDiff: (difference: number) => void;\n    requestSeekForward: (difference?: number) => void;\n    requestToggleFullscreen: () => void;\n    requestToggleMute: (forceValue?: boolean) => void;\n    requestTogglePictureInPicture: () => void;\n    requestVolume: (volume: number) => void;\n    setAutohide: (autohide: number) => void;\n    setFullscreen: (fullscreen: boolean) => void;\n    // biome-ignore lint/suspicious/noExplicitAny: no hls.js\n    setHlsConfig: (hlsConfig: any) => void;\n    setLive: (live: boolean) => void;\n    setMounted: () => void;\n    setPictureInPicture: (pictureInPicture: boolean) => void;\n    setPlaybackRate: (rate: number | string) => void;\n    setPoster: (poster: string | null) => void;\n    setVideoQuality: (videoQuality: VideoQuality) => void;\n    setSize: (size: Partial<MediaSizing>) => void;\n    setVolume: (volume: number) => void;\n    setWebsocketMetadata: (metadata: Metadata) => void;\n    togglePlay: (force?: boolean) => void;\n    updateBuffered: (buffered: number) => void;\n    updateLastInteraction: () => void;\n    updatePlaybackOffsetMs: (offset: number) => void;\n  };\n\n  /** The device information and support. */\n  __device: DeviceInformation;\n\n  /** The initial props passed into the component. */\n  __initialProps: InitialProps;\n\n  __metadata: Metadata | null;\n};\n\nexport type MediaControllerStore = StoreApi<MediaControllerState> & {\n  subscribe: {\n    (\n      listener: (\n        selectedState: MediaControllerState,\n        previousSelectedState: MediaControllerState,\n      ) => void,\n    ): () => void;\n    <U>(\n      selector: (state: MediaControllerState) => U,\n      listener: (selectedState: U, previousSelectedState: U) => void,\n      options?: {\n        equalityFn?: (a: U, b: U) => boolean;\n        fireImmediately?: boolean;\n      },\n    ): () => void;\n  };\n  persist: {\n    onFinishHydration: (\n      fn: (state: MediaControllerState) => void,\n    ) => () => void;\n  };\n};\n\nexport const createControllerStore = ({\n  device,\n  storage,\n  src,\n  initialProps,\n  playbackId,\n}: {\n  device: DeviceInformation;\n  storage: ClientStorage;\n  src: Src[] | string | null;\n  initialProps: Partial<InitialProps>;\n  playbackId?: string;\n}): { store: MediaControllerStore; destroy: () => void } => {\n  const initialPlaybackRate = initialProps?.playbackRate ?? 1;\n  const initialVolume = getBoundedVolume(\n    initialProps.volume ?? DEFAULT_VOLUME_LEVEL,\n  );\n  const initialVideoQuality = initialProps.videoQuality ?? \"auto\";\n\n  const sessionToken = generateRandomToken();\n\n  const thumbnailSrc =\n    typeof src === \"string\"\n      ? null\n      : (src?.find?.((s) => s.type === \"image\") as ImageSrc | null | undefined);\n\n  const lowLatency = initialProps.lowLatency ?? true;\n\n  const parsedInputSource = getNewSource({\n    accessKey: initialProps?.accessKey,\n    aspectRatio: initialProps?.aspectRatio,\n    isHlsSupported: device.isHlsSupported,\n    jwt: initialProps?.jwt,\n    playbackRate: initialPlaybackRate,\n    lowLatency,\n    screenWidth: device.screenWidth,\n    sessionToken,\n    src,\n    videoQuality: initialVideoQuality,\n  });\n\n  const initialControls: ControlsState = {\n    hlsConfig: null,\n    autohide: DEFAULT_AUTOHIDE_TIME,\n    lastError: 0,\n    lastInteraction: Date.now(),\n    requestedMeasureLastTime: 0,\n    muted: initialVolume === 0,\n    playbackId: playbackId ?? parsedInputSource?.playbackId ?? null,\n    playbackOffsetMs: null,\n    playLastTime: 0,\n    requestedClipParams: null,\n    requestedFullscreenLastTime: 0,\n    requestedPictureInPictureLastTime: 0,\n    requestedPlayPauseLastTime: 0,\n    requestedRangeToSeekTo: 0,\n    sessionToken,\n    size: null,\n    thumbnail: thumbnailSrc ?? null,\n    volume: initialVolume,\n  };\n\n  const store = createStore<\n    MediaControllerState,\n    [\n      [\"zustand/subscribeWithSelector\", Partial<MediaControllerState>],\n      [\"zustand/persist\", Partial<MediaControllerState>],\n    ]\n  >(\n    subscribeWithSelector(\n      persist(\n        (set, get) => ({\n          currentSource: parsedInputSource.currentSource,\n\n          canPlay: false,\n          hidden: false,\n\n          /** Current volume of the media. 0 if it is muted. */\n          volume: initialVolume,\n          /** The playback rate for the media. Defaults to 1. */\n          playbackRate: initialPlaybackRate,\n          videoQuality: \"auto\",\n\n          /** Current progress of the media (in seconds) */\n          progress: 0,\n          /** Current total duration of the media (in seconds) */\n          duration: 0,\n          /** Current buffered end time for the media (in seconds) */\n          buffered: 0,\n          /** Current buffered percent */\n          bufferedPercent: 0,\n\n          poster: thumbnailSrc?.src ?? null,\n\n          /** If the video element is mounted on the DOM */\n          mounted: false,\n\n          /** If the media is fullscreen. */\n          fullscreen: false,\n          /** If the media is in picture in picture mode */\n          pictureInPicture: false,\n\n          playing: false,\n          waiting: false,\n          stalled: false,\n          loading: true,\n          ended: false,\n\n          /** If the media has experienced an error. */\n          error: null,\n          errorCount: 0,\n\n          /** If the content is live media */\n          live: false,\n\n          /** If the media has been played yet. */\n          hasPlayed: false,\n\n          /** The sorted sources that were passed in to the Player */\n          sortedSources: parsedInputSource.sortedSources,\n\n          /** The final playback URL for the media that is playing, after redirects. */\n          currentUrl: null,\n\n          aria: {\n            progress: \"No progress, content is loading\",\n            fullscreen: \"Full screen (f)\",\n            pictureInPicture: \"Mini player (i)\",\n            playPause: \"Play (k)\",\n            clip: initialProps.clipLength\n              ? `Clip last ${Number(initialProps.clipLength).toFixed(\n                  0,\n                )} seconds (x)`\n              : null,\n            time: \"0:00\",\n          },\n\n          __initialProps: {\n            accessKey: initialProps.accessKey ?? null,\n            aspectRatio: initialProps?.aspectRatio ?? null,\n            autoPlay: initialProps.autoPlay ?? false,\n            backoff: Math.max(initialProps.backoff ?? 500, 100),\n            backoffMax: Math.max(initialProps.backoffMax ?? 30000, 10000),\n            clipLength: initialProps.clipLength ?? null,\n            hotkeys: initialProps?.hotkeys ?? true,\n            jwt: initialProps.jwt ?? null,\n            lowLatency,\n            onError: initialProps?.onError ?? null,\n            playbackRate: initialPlaybackRate,\n            posterLiveUpdate: initialProps.posterLiveUpdate ?? 30000,\n            preload: initialProps.preload ?? \"none\",\n            storage,\n            timeout: initialProps.timeout ?? 10000,\n            videoQuality: initialVideoQuality,\n            viewerId: initialProps.viewerId ?? null,\n            volume: initialVolume ?? null,\n          },\n\n          __device: device,\n\n          __controls: initialControls,\n\n          __metadata: null,\n\n          __controlsFunctions: {\n            setMounted: () =>\n              set(() => ({\n                mounted: true,\n              })),\n            setPoster: (poster: string | null) =>\n              set(() => ({\n                poster,\n              })),\n\n            setAutohide: (autohide) =>\n              set(({ __controls }) => ({\n                __controls: {\n                  ...__controls,\n                  autohide,\n                },\n              })),\n\n            setHlsConfig: (hlsConfig) =>\n              set(({ __controls }) => ({\n                __controls: {\n                  ...__controls,\n                  hlsConfig,\n                },\n              })),\n\n            setHidden: (hidden: boolean) =>\n              set(({ playing }) => ({\n                hidden: playing ? hidden : false,\n              })),\n            updateLastInteraction: () =>\n              set(({ __controls }) => ({\n                __controls: { ...__controls, lastInteraction: Date.now() },\n              })),\n\n            updatePlaybackOffsetMs: (offset: number) =>\n              set(({ __controls }) => ({\n                __controls: {\n                  ...__controls,\n                  playbackOffsetMs: offset,\n                },\n              })),\n\n            onCanPlay: () =>\n              set(() => ({\n                canPlay: true,\n                loading: false,\n              })),\n\n            onPlay: () =>\n              set(({ aria, __controls, __controlsFunctions }) => {\n                __controlsFunctions.onError(null);\n\n                const title = \"Pause (k)\";\n\n                return {\n                  playing: true,\n                  hasPlayed: true,\n                  error: null,\n                  errorCount: 0,\n\n                  stalled: false,\n                  waiting: false,\n                  ended: false,\n                  __controls: {\n                    ...__controls,\n                    playLastTime: Date.now(),\n                  },\n                  aria: {\n                    ...aria,\n                    playPause: title,\n                  },\n                };\n              }),\n            onPause: () =>\n              set(({ aria }) => {\n                const title = \"Play (k)\";\n\n                return {\n                  playing: false,\n                  hidden: false,\n                  stalled: false,\n                  waiting: false,\n                  ended: false,\n                  aria: {\n                    ...aria,\n                    playPause: title,\n                  },\n                };\n              }),\n            togglePlay: (force?: boolean) => {\n              const { hidden, __device, __controlsFunctions } =\n                store.getState();\n              if (!force && hidden && __device.isMobile) {\n                __controlsFunctions.setHidden(false);\n              } else {\n                set(({ __controls }) => ({\n                  __controls: {\n                    ...__controls,\n                    requestedPlayPauseLastTime: Date.now(),\n                    lastInteraction: Date.now(),\n                  },\n                }));\n              }\n            },\n            onProgress: (time) =>\n              set(({ aria, progress, duration, live }) => {\n                const progressAria = getProgressAria({\n                  progress,\n                  duration,\n                  live,\n                });\n\n                const playPauseTitle = \"Pause (k)\";\n\n                return {\n                  aria: {\n                    ...aria,\n                    progress: progressAria.progress,\n                    time: progressAria.time,\n                    playPause: playPauseTitle,\n                  },\n                  progress: getFilteredNaN(time),\n                  waiting: false,\n                  stalled: false,\n                  ended: false,\n                };\n              }),\n            requestSeek: (time) =>\n              set(({ duration, __controls }) => ({\n                __controls: {\n                  ...__controls,\n                  requestedRangeToSeekTo: getBoundedSeek(time, duration),\n                },\n                progress: getBoundedSeek(time, duration),\n              })),\n\n            onDurationChange: (duration) =>\n              set(({ live }) => ({\n                duration,\n                live: duration === Number.POSITIVE_INFINITY ? true : live,\n              })),\n\n            setWebsocketMetadata: (metadata: Metadata) =>\n              set(() => ({ __metadata: metadata })),\n\n            updateBuffered: (buffered) =>\n              set(({ duration }) => {\n                const durationFiltered = getFilteredNaN(duration);\n\n                const percent =\n                  durationFiltered > 0 && buffered > 0\n                    ? (buffered / durationFiltered) * 100\n                    : 0;\n\n                return {\n                  buffered,\n                  bufferedPercent: Number(percent.toFixed(2)),\n                };\n              }),\n\n            setVideoQuality: (videoQuality) =>\n              set(({ __initialProps, __controls, playbackRate, __device }) => {\n                const parsedSourceNew = getNewSource({\n                  accessKey: __initialProps?.accessKey,\n                  aspectRatio: __initialProps.aspectRatio,\n                  isHlsSupported: __device.isHlsSupported,\n                  jwt: __initialProps?.jwt,\n                  lowLatency: __initialProps.lowLatency,\n                  playbackRate,\n                  screenWidth: device.screenWidth,\n                  sessionToken: __controls.sessionToken,\n                  src,\n                  videoQuality,\n                });\n\n                return {\n                  sortedSources: parsedSourceNew.sortedSources,\n                  videoQuality,\n\n                  currentSource: parsedSourceNew.currentSource,\n                  __controls: {\n                    ...__controls,\n                    playbackId: playbackId ?? parsedSourceNew.playbackId,\n                  },\n                };\n              }),\n\n            setPlaybackRate: (rate) =>\n              set(() => ({\n                playbackRate: getBoundedRate(rate ?? 1),\n              })),\n\n            requestSeekDiff: (difference) =>\n              set(({ progress, duration, __controls }) => ({\n                __controls: {\n                  ...__controls,\n                  requestedRangeToSeekTo: getBoundedSeek(\n                    getFilteredNaN(progress) + difference / 1000,\n                    duration,\n                  ),\n                },\n              })),\n            requestSeekBack: (difference = DEFAULT_SEEK_TIME) =>\n              get().__controlsFunctions.requestSeekDiff(-difference),\n            requestSeekForward: (difference = DEFAULT_SEEK_TIME) =>\n              get().__controlsFunctions.requestSeekDiff(difference),\n\n            onFinalUrl: (currentUrl: string | null) =>\n              set(() => ({ currentUrl })),\n\n            requestMeasure: () =>\n              set(({ __controls }) => {\n                return {\n                  __controls: {\n                    ...__controls,\n                    requestedMeasureLastTime: Date.now(),\n                  },\n                } as const;\n              }),\n\n            setSize: (size: Partial<MediaSizing>) =>\n              set(({ __controls }) => {\n                return {\n                  __controls: {\n                    ...__controls,\n                    size: {\n                      ...__controls.size,\n                      ...size,\n                    },\n                  },\n                } as const;\n              }),\n            onWaiting: () => set(() => ({ waiting: true })),\n            onStalled: () => set(() => ({ stalled: true })),\n            onLoading: () => set(() => ({ loading: true })),\n            onEnded: () => set(() => ({ ended: true })),\n\n            setFullscreen: (fullscreen: boolean) =>\n              set(({ aria }) => {\n                const title = fullscreen\n                  ? \"Exit full screen (f)\"\n                  : \"Full screen (f)\";\n\n                return {\n                  fullscreen,\n                  aria: {\n                    ...aria,\n                    fullscreen: title,\n                  },\n                };\n              }),\n            requestToggleFullscreen: () =>\n              set(({ __controls }) => ({\n                __controls: {\n                  ...__controls,\n                  requestedFullscreenLastTime: Date.now(),\n                },\n              })),\n\n            setPictureInPicture: (pictureInPicture: boolean) =>\n              set(({ aria }) => {\n                const title = pictureInPicture\n                  ? \"Exit mini player (i)\"\n                  : \"Mini player (i)\";\n\n                return {\n                  pictureInPicture,\n                  aria: {\n                    ...aria,\n                    pictureInPicture: title,\n                  },\n                };\n              }),\n            requestTogglePictureInPicture: () =>\n              set(({ __controls }) => ({\n                __controls: {\n                  ...__controls,\n                  requestedPictureInPictureLastTime: Date.now(),\n                },\n              })),\n\n            setLive: (live: boolean) => set(() => ({ live })),\n\n            requestClip: () =>\n              set(({ __controls, __initialProps }) => ({\n                __controls: {\n                  ...__controls,\n\n                  requestedClipParams: __initialProps.clipLength\n                    ? getClipParams({\n                        requestedTime: Date.now(),\n                        clipLength: __initialProps.clipLength,\n                        playbackOffsetMs: __controls.playbackOffsetMs,\n                      })\n                    : null,\n                },\n              })),\n            requestVolume: (newVolume) =>\n              set(({ __controls }) => ({\n                volume: getBoundedVolume(newVolume),\n                __controls: {\n                  ...__controls,\n                  volume:\n                    newVolume === 0 ? newVolume : getBoundedVolume(newVolume),\n                  muted: newVolume === 0,\n                },\n              })),\n            setVolume: (newVolume) =>\n              set(({ __controls }) => ({\n                volume: getBoundedVolume(newVolume),\n                __controls: {\n                  ...__controls,\n                  muted: newVolume === 0,\n                },\n              })),\n\n            requestToggleMute: (forceValue?: boolean) =>\n              set(({ __controls }) => {\n                const previousVolume = getBoundedVolume(__controls.volume) || 0;\n                const nonMutedVolume =\n                  previousVolume > 0.01 ? previousVolume : DEFAULT_VOLUME_LEVEL;\n                const mutedVolume = 0;\n\n                const newMutedValue = forceValue ?? !__controls.muted;\n\n                return {\n                  volume: newMutedValue ? mutedVolume : nonMutedVolume,\n                  __controls: {\n                    ...__controls,\n                    muted: newMutedValue,\n                  },\n                };\n              }),\n\n            onError: (rawError: Error | null) =>\n              set(\n                ({\n                  currentSource,\n                  sortedSources,\n                  __controls,\n                  errorCount,\n                  __device,\n                  __initialProps,\n                  videoQuality,\n                  playbackRate,\n                }) => {\n                  const msSinceLastError = Date.now() - __controls.lastError;\n\n                  const error = rawError\n                    ? ({\n                        type: isAccessControlError(rawError)\n                          ? \"access-control\"\n                          : isBframesError(rawError) ||\n                              isNotAcceptableError(rawError)\n                            ? \"fallback\"\n                            : isStreamOfflineError(rawError)\n                              ? \"offline\"\n                              : isPermissionsError(rawError)\n                                ? \"permissions\"\n                                : \"unknown\",\n                        message: rawError?.message ?? \"Error with playback.\",\n                      } as const)\n                    : null;\n\n                  if (__initialProps.onError) {\n                    try {\n                      __initialProps.onError(error);\n                    } catch (e) {\n                      console.error(e);\n                    }\n                  }\n\n                  const base = {\n                    error,\n                    ...(error\n                      ? ({\n                          errorCount: errorCount + 1,\n                          playing: false,\n                          __controls: {\n                            ...__controls,\n                            lastError: Date.now(),\n                          },\n                        } as const)\n                      : { __controls }),\n                  } as const;\n\n                  // we return when there is no error\n                  if (!error) {\n                    return base;\n                  }\n\n                  console.error(error);\n\n                  // we increment the source only on a bframes or unknown error\n                  if (\n                    error.type === \"offline\" ||\n                    error.type === \"access-control\" ||\n                    error.type === \"permissions\"\n                  ) {\n                    return base;\n                  }\n\n                  if (\n                    typeof sortedSources === \"string\" ||\n                    !Array.isArray(sortedSources)\n                  ) {\n                    return base;\n                  }\n\n                  // we debounce the error fallback\n                  if (msSinceLastError < errorCount * 500) {\n                    return base;\n                  }\n\n                  const currentSourceBaseUrl = currentSource\n                    ? new URL(currentSource.src)\n                    : \"\";\n\n                  if (currentSourceBaseUrl) {\n                    // Clear the search parameters\n                    currentSourceBaseUrl.search = \"\";\n                  }\n\n                  const currentSourceIndex = sortedSources.findIndex(\n                    (s) => s.src === currentSourceBaseUrl.toString(),\n                  );\n\n                  // Create a new array that starts from the next index and wraps around\n                  const rotatedSources = [\n                    ...sortedSources.slice(currentSourceIndex + 1),\n                    ...sortedSources.slice(0, currentSourceIndex + 1),\n                  ];\n\n                  // Function to determine if a source type can be played\n                  const canPlaySourceType = (src: Src) => {\n                    const hasOneWebRTCSource = sortedSources.some(\n                      (s) => s?.type === \"webrtc\",\n                    );\n\n                    // if low latency is forced, and there is at least one webrtc source, don't play non-webrtc\n                    if (\n                      __initialProps.lowLatency === \"force\" &&\n                      hasOneWebRTCSource &&\n                      src.type !== \"webrtc\"\n                    ) {\n                      return false;\n                    }\n\n                    // if low latency is turned off, do not play webrtc\n                    if (__initialProps.lowLatency === false) {\n                      return src.type !== \"webrtc\";\n                    }\n\n                    // else play if webrtc is supported\n                    return src.type === \"webrtc\"\n                      ? __device.isWebRTCSupported\n                      : true;\n                  };\n\n                  // Find the next index in the rotated array where the source can be played\n                  const nextPlayableIndex = rotatedSources.findIndex((s) =>\n                    canPlaySourceType(s),\n                  );\n\n                  // Adjust the index to account for the rotation\n                  const nextSourceIndex =\n                    nextPlayableIndex !== -1\n                      ? (currentSourceIndex + 1 + nextPlayableIndex) %\n                        sortedSources.length\n                      : -1;\n\n                  // get the next source\n                  const nextSource =\n                    nextSourceIndex !== -1\n                      ? sortedSources[nextSourceIndex]\n                      : null;\n\n                  const parsedSourceNew = parseCurrentSourceAndPlaybackId({\n                    accessKey: __initialProps?.accessKey ?? null,\n                    aspectRatio: __initialProps?.aspectRatio ?? null,\n                    isHlsSupported: __device.isHlsSupported,\n                    jwt: __initialProps?.jwt ?? null,\n                    playbackRate,\n                    sessionToken: __controls.sessionToken,\n                    source: nextSource,\n                    videoQuality,\n                  });\n\n                  return {\n                    ...base,\n                    currentSource: parsedSourceNew?.currentSource ?? null,\n                    __controls: {\n                      ...base.__controls,\n                      playbackId:\n                        playbackId ?? parsedSourceNew?.playbackId ?? null,\n                    },\n                  };\n                },\n              ),\n          },\n        }),\n        {\n          name: \"livepeer-media-controller\",\n          version: 2,\n          // since these values are persisted across media, only persist volume, playbackRate, videoQuality\n          partialize: ({ volume, videoQuality }) => ({\n            volume,\n            videoQuality,\n          }),\n          storage: createJSONStorage(() => storage),\n        },\n      ),\n    ),\n  );\n\n  const destroy = store.persist.onFinishHydration(\n    ({ videoQuality, volume }) => {\n      if (videoQuality !== store.getState().videoQuality) {\n        store.getState().__controlsFunctions.setVideoQuality(videoQuality);\n      }\n      if (volume !== store.getState().volume) {\n        store.getState().__controlsFunctions.requestVolume(volume);\n      }\n    },\n  );\n\n  return { store, destroy };\n};\n","export const STREAM_OPEN_ERROR_MESSAGE = \"stream open failed\";\nexport const STREAM_OFFLINE_ERROR_MESSAGE = \"stream is offline\";\nexport const STREAM_WAITING_FOR_DATA_ERROR_MESSAGE =\n  \"stream is waiting for data\";\nexport const ACCESS_CONTROL_ERROR_MESSAGE =\n  \"shutting down since this session is not allowed to view this stream\";\nexport const BFRAMES_ERROR_MESSAGE =\n  \"metadata indicates that webrtc playback contains bframes\";\nexport const NOT_ACCEPTABLE_ERROR_MESSAGE =\n  \"response indicates unacceptable playback protocol\";\nexport const PERMISSIONS_ERROR_MESSAGE =\n  \"user did not allow the permissions request\";\n\nexport const isStreamOfflineError = (error: Error): boolean =>\n  error.message.toLowerCase().includes(STREAM_OPEN_ERROR_MESSAGE) ||\n  error.message.toLowerCase().includes(STREAM_WAITING_FOR_DATA_ERROR_MESSAGE) ||\n  error.message.toLowerCase().includes(STREAM_OFFLINE_ERROR_MESSAGE);\n\nexport const isAccessControlError = (error: Error): boolean =>\n  error.message.toLowerCase().includes(ACCESS_CONTROL_ERROR_MESSAGE);\n\nexport const isBframesError = (error: Error): boolean =>\n  error.message.toLowerCase().includes(BFRAMES_ERROR_MESSAGE);\n\nexport const isNotAcceptableError = (error: Error): boolean =>\n  error.message.toLowerCase().includes(NOT_ACCEPTABLE_ERROR_MESSAGE);\n\nexport const isPermissionsError = (error: Error): boolean =>\n  error.message.toLowerCase().includes(PERMISSIONS_ERROR_MESSAGE);\n","const LP_DOMAINS = [\"livepeer\", \"livepeercdn\", \"lp-playback\"];\n\n// Finds the metrics reporting URL from a playback ID and a playback domain\nexport const getMetricsReportingUrl = async (\n  playbackId: string | null,\n  playbackUrl: string,\n  sessionToken?: string | null,\n): Promise<string | null> => {\n  try {\n    // This is either:\n    // https://mdw-staging-staging-catalyst-0.livepeer.monster/hls/video+{playbackId}/0_6/index.m3u8\n    // https://mdw-staging-staging-catalyst-0.livepeer.monster/webrtc/video+{playbackId}\n    // https://vod-cdn.lp-playback.monster/raw/{id}/catalyst-vod-monster/hls/{playbackId}/270p0.mp4\n    //\n    // And the websocket URL should be:\n    // wss://mdw-staging-staging-catalyst-0.livepeer.monster/json_video+{playbackId}.js?tkn=adb42a8f47438\n    const parsedUrl = new URL(playbackUrl);\n\n    const splitHost = parsedUrl.host.split(\".\");\n    const includesDomain = LP_DOMAINS.includes(\n      splitHost?.[splitHost.length - 2] ?? \"\",\n    );\n    const tld = (splitHost?.[splitHost?.length - 1] ?? null) as\n      | \"com\"\n      | \"studio\"\n      | \"fun\"\n      | \"monster\"\n      | null;\n\n    // map to known TLDs, with .com => .studio\n    const tldMapped =\n      tld === \"com\"\n        ? \"studio\"\n        : tld === \"studio\"\n          ? \"studio\"\n          : tld === \"fun\"\n            ? \"fun:20443\"\n            : tld === \"monster\"\n              ? \"monster\"\n              : null;\n\n    // if not a known TLD, then do not return a URL\n    if (playbackId && includesDomain && tldMapped) {\n      const isCatalystPlayback = parsedUrl.host.includes(\"catalyst\");\n\n      try {\n        const getRedirectedUrl = async (): Promise<string | null> => {\n          const response = await fetch(\n            `https://playback.livepeer.${tldMapped}/json_video+${playbackId}.js`,\n          );\n\n          return response?.url ?? null;\n        };\n\n        const finalUrl = isCatalystPlayback\n          ? `https://${parsedUrl.host}/json_video+${playbackId}.js`\n          : await getRedirectedUrl();\n\n        // parse the url which we're redirected to\n        const redirectedUrl = finalUrl?.replace(\"https:\", \"wss:\");\n\n        const url = redirectedUrl ? new URL(redirectedUrl) : null;\n\n        if (url && sessionToken) {\n          url.searchParams.set(\"tkn\", sessionToken);\n        }\n\n        return url?.toString?.() ?? null;\n      } catch (error) {\n        console.log(\"Could not fetch metrics reporting URL.\", error);\n      }\n    }\n  } catch (error) {\n    console.error((error as Error)?.message);\n    return null;\n  }\n\n  return null;\n};\n\nconst ASSET_URL_PART_VALUE = \"hls\";\nconst FLV_URL_PART_VALUE = \"flv\";\nconst WEBRTC_URL_PART_VALUE = \"webrtc\";\nconst RECORDING_URL_PART_VALUE = \"recordings\";\n\nexport const getPlaybackIdFromSourceUrl = (sourceUrl: string) => {\n  const parsedUrl = new URL(sourceUrl);\n\n  const parts = parsedUrl.pathname.split(\"/\");\n\n  const includesAssetUrl = parts.includes(ASSET_URL_PART_VALUE);\n  const includesWebRtcUrl = parts.includes(WEBRTC_URL_PART_VALUE);\n  const includesFlvUrl = parts.includes(FLV_URL_PART_VALUE);\n  const includesRecording = parts.includes(RECORDING_URL_PART_VALUE);\n\n  // Check if the url is valid\n  const playbackId =\n    includesWebRtcUrl || includesFlvUrl\n      ? parts?.[(parts?.length ?? 0) - 1]\n      : includesRecording || includesAssetUrl\n        ? parts?.[(parts?.length ?? 0) - 2] ?? null\n        : null;\n\n  if (playbackId?.includes(\"+\")) {\n    const split = playbackId.split(\"+\")?.[1];\n\n    if (split) {\n      return split;\n    }\n  }\n\n  return playbackId ?? null;\n};\n","export type MimeType = keyof typeof mime;\nexport type MimeValue = (typeof mime)[MimeType][number];\n\nexport const getMimeType = (ending: string): MimeType | null => {\n  for (const value of Object.keys(mime) as MimeType[]) {\n    if (mime[value]?.some((v) => v === ending)) {\n      return value;\n    }\n  }\n\n  return null;\n};\n\nconst mime = {\n  \"application/mp4\": [\"mp4s\", \"m4p\"],\n  \"application/ogg\": [\"ogx\"],\n  \"application/vnd.apple.mpegurl\": [\"m3u8\"],\n  \"audio/3gpp\": [\"*3gpp\"],\n  \"audio/adpcm\": [\"adp\"],\n  \"audio/amr\": [\"amr\"],\n  \"audio/basic\": [\"au\", \"snd\"],\n  \"audio/midi\": [\"mid\", \"midi\", \"kar\", \"rmi\"],\n  \"audio/mobile-xmf\": [\"mxmf\"],\n  \"audio/mp3\": [\"*mp3\"],\n  \"audio/mp4\": [\"m4a\", \"mp4a\"],\n  \"audio/mpeg\": [\"mpga\", \"mp2\", \"mp2a\", \"mp3\", \"m2a\", \"m3a\"],\n  \"audio/ogg\": [\"oga\", \"ogg\", \"spx\", \"opus\"],\n  \"audio/s3m\": [\"s3m\"],\n  \"audio/silk\": [\"sil\"],\n  \"audio/vnd.dece.audio\": [\"uva\", \"uvva\"],\n  \"audio/vnd.digital-winds\": [\"eol\"],\n  \"audio/vnd.dra\": [\"dra\"],\n  \"audio/vnd.dts.hd\": [\"dtshd\"],\n  \"audio/vnd.dts\": [\"dts\"],\n  \"audio/vnd.lucent.voice\": [\"lvp\"],\n  \"audio/vnd.ms-playready.media.pya\": [\"pya\"],\n  \"audio/vnd.nuera.ecelp4800\": [\"ecelp4800\"],\n  \"audio/vnd.nuera.ecelp7470\": [\"ecelp7470\"],\n  \"audio/vnd.nuera.ecelp9600\": [\"ecelp9600\"],\n  \"audio/vnd.rip\": [\"rip\"],\n  \"audio/wav\": [\"wav\"],\n  \"audio/wave\": [\"*wav\"],\n  \"audio/webm\": [\"weba\"],\n  \"audio/x-aac\": [\"aac\"],\n  \"audio/x-aiff\": [\"aif\", \"aiff\", \"aifc\"],\n  \"audio/x-caf\": [\"caf\"],\n  \"audio/x-flac\": [\"flac\"],\n  \"audio/x-m4a\": [\"*m4a\"],\n  \"audio/x-matroska\": [\"mka\"],\n  \"audio/x-mpegurl\": [\"m3u\"],\n  \"audio/x-ms-wax\": [\"wax\"],\n  \"audio/x-ms-wma\": [\"wma\"],\n  \"audio/x-pn-realaudio-plugin\": [\"rmp\"],\n  \"audio/x-pn-realaudio\": [\"ram\", \"ra\"],\n  \"audio/x-realaudio\": [\"*ra\"],\n  \"audio/x-wav\": [\"*wav\"],\n  \"audio/xm\": [\"xm\"],\n  \"video/3gpp\": [\"3gp\", \"3gpp\"],\n  \"video/3gpp2\": [\"3g2\"],\n  \"video/h261\": [\"h261\"],\n  \"video/h263\": [\"h263\"],\n  \"video/h264\": [\"h264\"],\n  \"video/iso.segment\": [\"m4s\"],\n  \"video/jpeg\": [\"jpgv\"],\n  \"video/jpm\": [\"*jpm\", \"jpgm\"],\n  \"video/mj2\": [\"mj2\", \"mjp2\"],\n  \"video/mp2t\": [\"ts\"],\n  \"video/mp4\": [\"mp4\", \"mp4v\", \"mpg4\"],\n  \"video/mpeg\": [\"mpeg\", \"mpg\", \"mpe\", \"m1v\", \"m2v\"],\n  \"video/ogg\": [\"ogv\"],\n  \"video/quicktime\": [\"qt\", \"mov\"],\n  \"video/vnd.dece.hd\": [\"uvh\", \"uvvh\"],\n  \"video/vnd.dece.mobile\": [\"uvm\", \"uvvm\"],\n  \"video/vnd.dece.pd\": [\"uvp\", \"uvvp\"],\n  \"video/vnd.dece.sd\": [\"uvs\", \"uvvs\"],\n  \"video/vnd.dece.video\": [\"uvv\", \"uvvv\"],\n  \"video/vnd.dvb.file\": [\"dvb\"],\n  \"video/vnd.fvt\": [\"fvt\"],\n  \"video/vnd.mpegurl\": [\"mxu\", \"m4u\"],\n  \"video/vnd.ms-playready.media.pyv\": [\"pyv\"],\n  \"video/vnd.uvvu.mp4\": [\"uvu\", \"uvvu\"],\n  \"video/vnd.vivo\": [\"viv\"],\n  \"video/vp8\": [\"vp8\"],\n  \"video/webm\": [\"webm\"],\n  \"video/x-f4v\": [\"f4v\"],\n  \"video/x-fli\": [\"fli\"],\n  \"video/x-flv\": [\"flv\"],\n  \"video/x-m4v\": [\"m4v\"],\n  \"video/x-matroska\": [\"mkv\", \"mk3d\", \"mks\"],\n  \"video/x-mng\": [\"mng\"],\n  \"video/x-ms-asf\": [\"asf\", \"asx\"],\n  \"video/x-ms-vob\": [\"vob\"],\n  \"video/x-ms-wm\": [\"wm\"],\n  \"video/x-ms-wmv\": [\"wmv\"],\n  \"video/x-ms-wmx\": [\"wmx\"],\n  \"video/x-ms-wvx\": [\"wvx\"],\n  \"video/x-msvideo\": [\"avi\"],\n  \"video/x-sgi-movie\": [\"movie\"],\n  \"video/x-smv\": [\"smv\"],\n} as const;\n","import type { ElementSize } from \"./controller\";\nimport { type MimeType, getMimeType } from \"./mime\";\n\ntype AudioExtension =\n  | \"m4a\"\n  | \"mp4a\"\n  | \"mpga\"\n  | \"mp2\"\n  | \"mp2a\"\n  | \"mp3\"\n  | \"m2a\"\n  | \"m3a\"\n  | \"wav\"\n  | \"weba\"\n  | \"aac\"\n  | \"oga\"\n  | \"spx\";\ntype VideoExtension = \"mp4\" | \"ogv\" | \"webm\" | \"mov\" | \"m4v\" | \"avi\" | \"m3u8\";\ntype HlsExtension = \"m3u8\";\ntype VideoTextTrackExtension = \"vtt\";\n\ntype OptionalQueryParams = `?${string}` | \"\";\n\ntype BaseSrc = {\n  type: \"audio\" | \"video\" | \"hls\" | \"webrtc\" | \"image\" | \"vtt\";\n  src: string;\n  mime: MimeType | null;\n  width: number | null;\n  height: number | null;\n};\nexport interface AudioSrc extends BaseSrc {\n  type: \"audio\";\n  src: `${string}${AudioExtension}${OptionalQueryParams}`;\n}\nexport interface VideoSrc extends BaseSrc {\n  type: \"video\";\n  src: `${string}${VideoExtension}${OptionalQueryParams}`;\n}\nexport interface ImageSrc extends BaseSrc {\n  type: \"image\";\n  src: `${string}${OptionalQueryParams}`;\n}\nexport interface VideoTextTrackSrc extends BaseSrc {\n  type: \"vtt\";\n  src: `${string}${VideoTextTrackExtension}${OptionalQueryParams}`;\n}\n\nexport interface Base64Src extends BaseSrc {\n  type: \"video\";\n  src: `${string}`;\n}\nexport interface HlsSrc extends BaseSrc {\n  type: \"hls\";\n  src: `${string}${HlsExtension}${OptionalQueryParams}`;\n}\nexport interface WebRTCSrc extends BaseSrc {\n  type: \"webrtc\";\n  src: `${string}${OptionalQueryParams}`;\n}\nexport interface FlvSrc extends BaseSrc {\n  type: \"video\";\n  src: `${string}`;\n}\nexport type Src =\n  | AudioSrc\n  | HlsSrc\n  | FlvSrc\n  | VideoSrc\n  | Base64Src\n  | WebRTCSrc\n  | ImageSrc\n  | VideoTextTrackSrc;\n\nexport type AccessControlParams = {\n  jwt?: string | null;\n  accessKey?: string | null;\n};\n\nexport type VideoQuality =\n  | \"1080p\"\n  | \"720p\"\n  | \"480p\"\n  | \"360p\"\n  | \"240p\"\n  | \"144p\"\n  | \"auto\";\n\n/**\n * Represents a single track selector\n */\nexport type SingleTrackSelector =\n  /** Selects no tracks */\n  | \"none\"\n  /** Selects all tracks */\n  | \"all\"\n  /** Selects all tracks */\n  | \"*\"\n  /** Specific track ID */\n  | `${number}`\n  /** Highest bit rate */\n  | \"maxbps\"\n  /** Lowest bit rate */\n  | \"minbps\"\n  /** Specific bit rate */\n  | `${number}bps`\n  /** Specific bit rate */\n  | `${number}kbps`\n  /** Specific bit rate */\n  | `${number}mbps`\n  /** Greater than specific bit rate */\n  | `>${number}bps`\n  /** Greater than specific bit rate */\n  | `>${number}kbps`\n  /** Greater than specific bit rate */\n  | `>${number}mbps`\n  /** Less than specific bit rate */\n  | `<${number}bps`\n  /** Less than specific bit rate */\n  | `<${number}kbps`\n  /** Less than specific bit rate */\n  | `<${number}mbps`\n  /** Max less than specific bit rate */\n  | `max<${number}bps`\n  /** Max less than specific bit rate */\n  | `max<${number}kbps`\n  /** Max less than specific bit rate */\n  | `max<${number}mbps`;\n\n/**\n * Represents a single audio track selector\n */\nexport type SingleAudioTrackSelector =\n  | SingleTrackSelector\n  /** Channel count */\n  | \"surround\"\n  /** Channel count */\n  | \"mono\"\n  /** Channel count */\n  | \"stereo\"\n  /** Channel count */\n  | `${number}ch`;\n\n/**\n * Represents a single video track selector\n */\nexport type SingleVideoTrackSelector =\n  | SingleTrackSelector\n  /** Highest pixel surface area */\n  | \"maxres\"\n  /** Lowest pixel surface area */\n  | \"minres\"\n  /** Specific pixel surface area */\n  | `${number}x${number}`\n  /** Closest to specific pixel surface area */\n  | `~${number}x${number}`\n  /** Greater than pixel surface area */\n  | `>${number}x${number}`\n  /** Less than pixel surface area */\n  | `<${number}x${number}`\n  /** Resolution */\n  | \"720p\"\n  /** Resolution */\n  | \"1080p\"\n  /** Resolution */\n  | \"1440p\"\n  /** Resolution */\n  | \"2k\"\n  /** Resolution */\n  | \"4k\"\n  /** Resolution */\n  | \"5k\"\n  /** Resolution */\n  | \"8k\";\n\n/**\n * Generic track selector for a given type\n */\ntype TrackSelector<T extends string> =\n  | T\n  /** Union of selectors */\n  | `${T},${T}`\n  /** Difference of selectors */\n  | `${T},!${T}`\n  /** Intersection of selectors */\n  | `${T},|${T}`;\n\nexport type VideoTrackSelector = TrackSelector<SingleVideoTrackSelector>;\nexport type AudioTrackSelector = TrackSelector<SingleAudioTrackSelector>;\n\nconst audioExtensions =\n  /\\.(m4a|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\\?)/i;\nconst base64String = /data:video/i;\nconst hlsExtensions = /\\.(m3u8)($|\\?)/i;\nconst flvExtensions = /\\/(flv)\\//i;\nconst imageExtensions = /\\.(jpg|jpeg|png|gif|bmp|webp)($|\\?)/i;\nconst vttExtensions = /\\.(vtt)($|\\?)/i;\nconst mimeFromBase64Pattern = /data:(.+?);base64/;\nconst videoExtensions = /\\.(mp4|ogv|webm|mov|m4v|avi|m3u8)($|\\?)/i;\nconst webrtcExtensions = /(webrtc|sdp)/i;\n\nexport const getMediaSourceType = (\n  src: string | null,\n  opts?: {\n    sizing?: ElementSize;\n  },\n): Src | null => {\n  if (!src) {\n    return null;\n  }\n\n  const sourceTest = src?.toLowerCase();\n\n  const base64Mime = sourceTest.match(mimeFromBase64Pattern);\n  const resolvedWidth = opts?.sizing?.width ?? null;\n  const resolvedHeight = opts?.sizing?.height ?? null;\n\n  return webrtcExtensions.test(sourceTest)\n    ? {\n        type: \"webrtc\",\n        src: src as WebRTCSrc[\"src\"],\n        mime: \"video/h264\",\n        width: resolvedWidth,\n        height: resolvedHeight,\n      }\n    : hlsExtensions.test(sourceTest)\n      ? {\n          type: \"hls\",\n          src: src as HlsSrc[\"src\"],\n          mime: getMimeType(hlsExtensions.exec(sourceTest)?.[1] ?? \"\"),\n          width: resolvedWidth,\n          height: resolvedHeight,\n        }\n      : videoExtensions.test(sourceTest)\n        ? {\n            type: \"video\",\n            src: src as VideoSrc[\"src\"],\n            mime: getMimeType(videoExtensions.exec(sourceTest)?.[1] ?? \"\"),\n            width: resolvedWidth,\n            height: resolvedHeight,\n          }\n        : audioExtensions.test(sourceTest)\n          ? {\n              type: \"audio\",\n              src: src as AudioSrc[\"src\"],\n              mime: getMimeType(audioExtensions.exec(sourceTest)?.[1] ?? \"\"),\n              width: resolvedWidth,\n              height: resolvedHeight,\n            }\n          : base64String.test(sourceTest)\n            ? {\n                type: \"video\",\n                src: src as Base64Src[\"src\"],\n                mime: base64Mime ? (base64Mime[1] as MimeType) : \"video/mp4\",\n                width: resolvedWidth,\n                height: resolvedHeight,\n              }\n            : imageExtensions.test(sourceTest)\n              ? {\n                  type: \"image\",\n                  src: src as ImageSrc[\"src\"],\n                  mime: getMimeType(\n                    imageExtensions.exec(sourceTest)?.[1] ?? \"\",\n                  ),\n                  width: resolvedWidth,\n                  height: resolvedHeight,\n                }\n              : vttExtensions.test(sourceTest)\n                ? {\n                    type: \"vtt\",\n                    src: src as VideoTextTrackSrc[\"src\"],\n                    mime: getMimeType(\n                      vttExtensions.exec(sourceTest)?.[1] ?? \"\",\n                    ),\n                    width: null,\n                    height: null,\n                  }\n                : flvExtensions.test(sourceTest)\n                  ? {\n                      type: \"video\",\n                      src: src as FlvSrc[\"src\"],\n                      mime: \"video/x-flv\",\n                      width: resolvedWidth,\n                      height: resolvedHeight,\n                    }\n                  : null;\n};\n","import type { ClipParams, InitialProps } from \"./controller\";\nimport { getPlaybackIdFromSourceUrl } from \"./metrics-utils\";\nimport {\n  type Src,\n  type VideoQuality,\n  type VideoTrackSelector,\n  getMediaSourceType,\n} from \"./src\";\n\nexport const DEFAULT_ASPECT_RATIO = 16 / 9;\n\nexport const getFilteredNaN = (value: number | undefined | null) =>\n  value && !Number.isNaN(value) && Number.isFinite(value) ? value : 0;\n\nexport const getBoundedSeek = (seek: number, duration: number | undefined) =>\n  Math.min(\n    Math.max(0, getFilteredNaN(seek)),\n    // seek to near the end\n    getFilteredNaN(duration) ? getFilteredNaN(duration) - 0.01 : 0,\n  );\n\nexport const getBoundedRate = (rate: string | number) => {\n  if (typeof rate === \"number\") {\n    return Math.min(Math.max(0, getFilteredNaN(rate)), 20);\n  }\n  const match = String(rate).match(/(\\d+(\\.\\d+)?)/);\n  return match\n    ? Math.min(Math.max(0, getFilteredNaN(Number.parseFloat(match[0]))), 20)\n    : 1;\n};\n\nexport const getBoundedVolume = (volume: number) =>\n  Math.min(Math.max(0, getFilteredNaN(volume)), 1);\n\nexport const generateRandomToken = () => {\n  try {\n    return Math.random().toString(16).substring(2);\n  } catch (e) {\n    //\n  }\n\n  return \"none\" as const;\n};\n\nexport const getClipParams = ({\n  requestedTime,\n  clipLength,\n  playbackOffsetMs,\n}: {\n  requestedTime: number | null;\n  clipLength: number;\n  playbackOffsetMs: number | null;\n}): ClipParams => {\n  const currentTime = requestedTime ?? Date.now();\n\n  // we get the estimated time on the server that the user \"clipped\"\n  // by subtracting the offset from the recorded clip time\n  const estimatedServerClipTime = currentTime - (playbackOffsetMs ?? 0);\n  const startTime = estimatedServerClipTime - clipLength * 1000;\n  const endTime = estimatedServerClipTime;\n\n  return {\n    startTime,\n    endTime,\n  };\n};\n\nexport const getProgressAria = ({\n  progress,\n  duration,\n  live,\n}: {\n  progress: number | null | undefined;\n  duration: number | null | undefined;\n  live: boolean | null | undefined;\n}) => {\n  const progressParsed = getHoursMinutesSeconds(progress ?? null);\n  const durationParsed = getHoursMinutesSeconds(duration ?? null);\n\n  const progressText = `${\n    progressParsed.hours ? `${progressParsed.hours} hours ` : \"\"\n  }${progressParsed.minutes ? `${progressParsed.minutes} minutes ` : \"\"}${\n    progressParsed.seconds ? `${progressParsed.seconds} seconds` : \"\"\n  }` as const;\n  const durationText = `${\n    durationParsed.hours ? `${durationParsed.hours} hours ` : \"\"\n  }${durationParsed.minutes ? `${durationParsed.minutes} minutes ` : \"\"}${\n    durationParsed.seconds ? `${durationParsed.seconds} seconds` : \"\"\n  }` as const;\n\n  const progressDisplay = live\n    ? (`Live ${progressText}` as const)\n    : (`${progressText} of ${durationText}` as const);\n\n  const formattedTimeDisplay = getFormattedHoursMinutesSeconds(\n    progress ?? null,\n  );\n\n  const formattedDuration = getFormattedHoursMinutesSeconds(duration ?? null);\n\n  const formattedTime = live\n    ? formattedTimeDisplay\n    : (`${formattedTimeDisplay} / ${formattedDuration}` as const);\n\n  return {\n    progress: progressDisplay,\n    time: formattedTime,\n  };\n};\n\ntype SrcWithParentDelta = Src & {\n  parentWidthDelta: number | null;\n};\n\nconst sortSources = ({\n  src,\n  videoQuality,\n  screenWidth,\n  aspectRatio,\n  lowLatency,\n}: {\n  src: Src[] | string | null | undefined;\n  videoQuality: VideoQuality;\n  screenWidth: number | null;\n  aspectRatio: number;\n  lowLatency: InitialProps[\"lowLatency\"];\n}) => {\n  if (!src) {\n    return null;\n  }\n\n  if (typeof src === \"string\") {\n    const mediaSourceType = getMediaSourceType(src);\n    return mediaSourceType ? [mediaSourceType] : null;\n  }\n\n  const filteredVideoSources = src\n    .filter(\n      (s) =>\n        s.type === \"audio\" ||\n        s.type === \"hls\" ||\n        s.type === \"webrtc\" ||\n        s.type === \"video\",\n    )\n    .filter((s) => {\n      if (s.type === \"hls\" && lowLatency === \"force\") {\n        return false;\n      }\n      if (s.type === \"webrtc\" && lowLatency === false) {\n        return false;\n      }\n\n      return true;\n    });\n\n  const videoQualityDimensions = calculateVideoQualityDimensions(\n    videoQuality,\n    aspectRatio,\n  );\n\n  const targetWidth = videoQualityDimensions?.width ?? screenWidth ?? 1280;\n\n  const sourceWithParentDelta: SrcWithParentDelta[] =\n    filteredVideoSources?.map((s) =>\n      s.type === \"hls\" || s.type === \"webrtc\"\n        ? { ...s, parentWidthDelta: null }\n        : {\n            ...s,\n            parentWidthDelta:\n              // first we check if the URL contains the video quality selector\n              videoQuality &&\n              videoQuality !== \"auto\" &&\n              s?.src?.includes(videoQuality)\n                ? 0\n                : // otherwise use the width of the src\n                  s?.width\n                  ? Math.abs(targetWidth - s.width)\n                  : // otherwise guess the width of the src based on the url\n                    s?.src.includes(\"static360p\") ||\n                      s?.src.includes(\"low-bitrate\")\n                    ? Math.abs(targetWidth - 480)\n                    : s?.src.includes(\"static720p\")\n                      ? Math.abs(targetWidth - 1280)\n                      : s?.src.includes(\"static1080p\")\n                        ? Math.abs(targetWidth - 1920)\n                        : s?.src.includes(\"static2160p\")\n                          ? Math.abs(targetWidth - 3840)\n                          : null,\n          },\n    ) ?? [];\n\n  const sortedSources = sourceWithParentDelta.sort((a, b) => {\n    if (a.type === \"video\" && b.type === \"video\") {\n      // we sort the sources by the delta between the video width and the\n      // parent size (multiplied by a multiplier above)\n      return b?.parentWidthDelta !== null && a?.parentWidthDelta !== null\n        ? a.parentWidthDelta - b.parentWidthDelta\n        : 1;\n    }\n    if (a.type === \"video\" && (b.type === \"hls\" || b.type === \"webrtc\")) {\n      // if the type is an MP4, we prefer that to HLS/WebRTC due to better caching/less overhead\n      return -1;\n    }\n    if (a.type === \"webrtc\" && b.type === \"hls\") {\n      // if there is a webrtc source, we prefer that to HLS\n      return -1;\n    }\n\n    return 1;\n  });\n\n  return sortedSources;\n};\n\nexport const parseCurrentSourceAndPlaybackId = ({\n  accessKey,\n  aspectRatio,\n  playbackRate,\n  isHlsSupported,\n  jwt,\n  sessionToken,\n  source,\n  videoQuality,\n}: {\n  accessKey: InitialProps[\"accessKey\"];\n  aspectRatio: InitialProps[\"aspectRatio\"];\n  playbackRate: InitialProps[\"playbackRate\"];\n  isHlsSupported: boolean;\n  jwt: InitialProps[\"jwt\"];\n  sessionToken: string;\n  source: Src | null;\n  videoQuality: VideoQuality;\n}) => {\n  if (!source) {\n    return null;\n  }\n\n  const playbackId = getPlaybackIdFromSourceUrl(source.src);\n\n  const url = new URL(source.src);\n\n  // append the tkn to the query params\n  if (sessionToken) {\n    url.searchParams.append(\"tkn\", sessionToken);\n  }\n\n  // we use headers for HLS and WebRTC for auth\n  if (source.type !== \"webrtc\" && source.type !== \"hls\") {\n    // append the JWT to the query params\n    if (jwt) {\n      url.searchParams.append(\"jwt\", jwt);\n    }\n    // or append the access key to the query params\n    else if (accessKey) {\n      url.searchParams.append(\"accessKey\", accessKey);\n    }\n  }\n\n  // for webrtc, we append specific parameters to control the config\n  if (source.type === \"webrtc\") {\n    if (playbackRate === \"constant\") {\n      url.searchParams.append(\"constant\", \"true\");\n    }\n\n    const videoTrackSelector = getVideoTrackSelectorForQuality(\n      videoQuality,\n      aspectRatio,\n    );\n\n    if (videoTrackSelector) {\n      url.searchParams.append(\"video\", videoTrackSelector);\n    }\n  }\n\n  // override the url with the new URL\n  const newSrc = {\n    ...source,\n    src: url.toString(),\n  } as Src;\n\n  const videoSourceIfHlsUnsupported =\n    newSrc?.type === \"hls\" && !isHlsSupported\n      ? ({\n          ...newSrc,\n          type: \"video\",\n        } as const)\n      : newSrc;\n\n  return {\n    currentSource: videoSourceIfHlsUnsupported,\n    playbackId,\n  } as const;\n};\n\nexport const getNewSource = ({\n  accessKey,\n  aspectRatio,\n  isHlsSupported,\n  jwt,\n  lowLatency,\n  playbackRate,\n  screenWidth,\n  sessionToken,\n  src,\n  videoQuality,\n}: {\n  accessKey: InitialProps[\"accessKey\"] | undefined;\n  aspectRatio: InitialProps[\"aspectRatio\"] | undefined;\n  isHlsSupported: boolean;\n  jwt: InitialProps[\"jwt\"] | undefined;\n  lowLatency: InitialProps[\"lowLatency\"];\n  playbackRate: InitialProps[\"playbackRate\"];\n  screenWidth: number | null;\n  sessionToken: string;\n  src: Src[] | string | null | undefined;\n  videoQuality: VideoQuality;\n}) => {\n  const sortedSources = sortSources({\n    src,\n    screenWidth,\n    videoQuality,\n    aspectRatio: aspectRatio ?? DEFAULT_ASPECT_RATIO,\n    lowLatency,\n  });\n\n  const parsedSource = parseCurrentSourceAndPlaybackId({\n    accessKey: accessKey ?? null,\n    aspectRatio: aspectRatio ?? null,\n    isHlsSupported: isHlsSupported,\n    jwt: jwt ?? null,\n    playbackRate,\n    sessionToken: sessionToken,\n    source: sortedSources?.[0] ?? null,\n    videoQuality,\n  });\n\n  return {\n    currentSource: parsedSource?.currentSource ?? null,\n    playbackId: parsedSource?.playbackId ?? null,\n    sortedSources,\n  } as const;\n};\n\nexport const getVideoTrackSelectorForQuality = (\n  videoQuality: VideoQuality,\n  aspectRatio: InitialProps[\"aspectRatio\"],\n): VideoTrackSelector | null => {\n  if (videoQuality === \"auto\") {\n    return null;\n  }\n\n  const videoQualityDimensions = calculateVideoQualityDimensions(\n    videoQuality,\n    aspectRatio,\n  );\n\n  if (videoQualityDimensions?.width && videoQualityDimensions?.height) {\n    return `~${videoQualityDimensions.width}x${videoQualityDimensions.height}`;\n  }\n\n  return null;\n};\n\nexport function calculateVideoQualityDimensions(\n  videoQuality: VideoQuality,\n  aspectRatio: InitialProps[\"aspectRatio\"],\n) {\n  const height =\n    videoQuality === \"1080p\"\n      ? 1080\n      : videoQuality === \"720p\"\n        ? 720\n        : videoQuality === \"480p\"\n          ? 480\n          : videoQuality === \"360p\"\n            ? 360\n            : videoQuality === \"240p\"\n              ? 240\n              : videoQuality === \"144p\"\n                ? 144\n                : null;\n\n  return {\n    width:\n      height !== null ? Math.round(height * (aspectRatio ?? 16 / 9)) : null,\n    height,\n  };\n}\n\nexport const getFormattedHoursMinutesSeconds = (\n  valueInSeconds: number | undefined | null,\n) => {\n  const hoursMinutesSeconds = getHoursMinutesSeconds(valueInSeconds);\n  if (\n    hoursMinutesSeconds.seconds ||\n    hoursMinutesSeconds.minutes ||\n    hoursMinutesSeconds.hours\n  ) {\n    if (hoursMinutesSeconds.hours > 0) {\n      return `${hoursMinutesSeconds.hours}:${hoursMinutesSeconds.minutes\n        .toString()\n        .padStart(2, \"0\")}:${hoursMinutesSeconds.seconds < 10 ? \"0\" : \"\"}${\n        hoursMinutesSeconds.seconds\n      }` as const;\n    }\n\n    return `${hoursMinutesSeconds.minutes}:${hoursMinutesSeconds.seconds\n      .toString()\n      .padStart(2, \"0\")}` as const;\n  }\n\n  return \"0:00\" as const;\n};\n\nexport const getHoursMinutesSeconds = (\n  valueInSeconds: number | undefined | null,\n) => {\n  if (\n    valueInSeconds !== undefined &&\n    valueInSeconds !== null &&\n    !Number.isNaN(valueInSeconds) &&\n    Number.isFinite(valueInSeconds)\n  ) {\n    const roundedValue = Math.round(valueInSeconds);\n\n    const hours = Math.floor(roundedValue / 3600);\n    const seconds = Math.floor(roundedValue % 60);\n\n    if (hours > 0) {\n      const minutes = Math.floor((roundedValue % 3600) / 60);\n\n      return {\n        hours,\n        minutes,\n        seconds,\n      } as const;\n    }\n\n    const minutes = Math.floor(roundedValue / 60);\n\n    return {\n      hours: 0,\n      minutes,\n      seconds,\n    } as const;\n  }\n\n  return {\n    hours: 0,\n    minutes: 0,\n    seconds: 0,\n  } as const;\n};\n","import type { MediaControllerStore } from \"./controller\";\nimport { getMetricsReportingUrl } from \"./metrics-utils\";\nimport type { MimeType } from \"./mime\";\n\ntype MetricsOpts = {\n  /**\n   * Disables the `progress` event listener, which is used to monitor when media is in a \"playing\" state.\n   */\n  disableProgressListener?: boolean;\n};\n\ntype RawMetrics = {\n  preloadTime: number | null;\n  ttff: number | null;\n  firstPlayback: number | null;\n\n  nWaiting: number | null;\n  timeWaiting: number;\n\n  nStalled: number | null;\n  timeStalled: number;\n\n  timeUnpaused: number;\n\n  nError: number | null;\n  lastError?: string;\n\n  videoHeight: number | null;\n  videoWidth: number | null;\n  playerHeight: number | null;\n  playerWidth: number | null;\n\n  playbackScore: number | null;\n\n  player: `${\n    | \"audio\"\n    | \"hls\"\n    | \"video\"\n    | \"webrtc\"\n    | \"image\"\n    | \"vtt\"\n    | \"unknown\"}-${string}`;\n\n  sourceType: MimeType | \"unknown\";\n\n  offset: number | null;\n\n  pageUrl: string;\n  sourceUrl: string | null;\n  duration: number | null;\n\n  autoplay: \"autoplay\" | \"preload-full\" | \"preload-metadata\" | \"standard\";\n  userAgent: string;\n\n  uid: string;\n};\n\ntype PlaybackRecord = {\n  clockTime: number;\n  mediaTime: number;\n  score: number;\n};\n\nexport class PlaybackMonitor {\n  active = false;\n  values: PlaybackRecord[] = [];\n  score: number | null = null;\n  averagingSteps = 20;\n  store: MediaControllerStore;\n\n  constructor(store: MediaControllerStore) {\n    this.store = store;\n  }\n\n  init() {\n    if (!this.active) {\n      this.values = [];\n      this.score = null;\n\n      this.active = true;\n    }\n  }\n  reset() {\n    if (!this.active) {\n      // it's not running, start it up\n      this.init();\n    } else {\n      this.values = [];\n    }\n  }\n  destroy() {\n    if (this.active) {\n      this.values = [];\n      this.score = null;\n      this.active = false;\n    }\n  }\n\n  calculateScore() {\n    if (this.active) {\n      // save the current testing value and time\n      // If the media plays, this should keep a constant value. If the media is stalled, it will go up with 1sec/sec. If the media is playing faster, it will go down.\n      // current clock time - current playback time\n      const latestPlaybackRecord =\n        this.values.length > 0\n          ? this.values[this.values.length - 1]\n          : undefined;\n\n      const currentValue = {\n        clockTime: Date.now() * 1e-3,\n        mediaTime: this.store.getState().progress,\n        score: latestPlaybackRecord\n          ? this.valueToScore(latestPlaybackRecord)\n          : 0,\n      };\n\n      this.values.push(currentValue); // add the current value to the history\n\n      // no history yet, can't calculate a score\n      if (this.values.length < 2) {\n        return null;\n      }\n\n      const oldestValue = this.values[0];\n\n      if (oldestValue !== undefined) {\n        // diff between oldest score and current\n        const averagedScore = this.valueToScore(oldestValue, currentValue); // should be 1, decreases if bad\n\n        // kick the oldest value from the array\n        if (this.values.length > this.averagingSteps) {\n          this.values.shift();\n        }\n\n        // the final score is the maximum of the averaged and the current value\n        this.score = Math.max(averagedScore, currentValue.score);\n\n        return Math.round(this.score * 10) / 10;\n      }\n    }\n\n    return null;\n  }\n\n  valueToScore(a: PlaybackRecord, b?: PlaybackRecord) {\n    // calculate the moving average\n    // if this returns > 1, the media played faster than the clock\n    // if this returns < 0, the media time went backwards\n    const rate = this?.store?.getState?.()?.playbackRate ?? 1;\n\n    return (\n      (b?.mediaTime ?? this.store.getState().progress - a.mediaTime) /\n      (b?.clockTime ?? Date.now() * 1e-3 - a.clockTime) /\n      (rate === \"constant\" ? 1 : rate)\n    );\n  }\n}\n\nclass Timer {\n  totalTime = 0;\n\n  countStarts = 0;\n  startTime = 0;\n\n  start() {\n    this.startTime = Date.now();\n    this.countStarts++;\n  }\n  stop() {\n    this.totalTime += this.startTime > 0 ? Date.now() - this.startTime : 0;\n    this.startTime = 0;\n  }\n  getTotalTime() {\n    this.totalTime += this.startTime > 0 ? Date.now() - this.startTime : 0;\n    this.startTime = this.startTime > 0 ? Date.now() : 0;\n\n    return this.totalTime;\n  }\n  getCountStarts() {\n    return this.countStarts;\n  }\n}\n\nfunction isInIframe() {\n  try {\n    return typeof window !== \"undefined\" && window.self !== window.top;\n  } catch (e) {\n    // if accessing window.top throws an exception due to cross-origin policy, the catch block will also return true,\n    // indicating the code is running inside an iframe\n    return true;\n  }\n}\n\nexport class MetricsStatus {\n  requestedPlayTime: number | null = null;\n  firstFrameTime: number | null = null;\n  bootMs: number;\n\n  retryCount = 0;\n  connected = false;\n  store: MediaControllerStore;\n\n  destroy: () => void;\n\n  currentMetrics: RawMetrics;\n  previousMetrics: RawMetrics | null = null;\n\n  timeWaiting = new Timer();\n  timeStalled = new Timer();\n  timeUnpaused = new Timer();\n\n  constructor(\n    store: MediaControllerStore,\n    bootMs: number,\n    opts: MetricsOpts | undefined,\n  ) {\n    const currentState = store.getState();\n\n    this.store = store;\n    this.bootMs = bootMs;\n\n    const windowHref =\n      typeof window !== \"undefined\" ? window?.location?.href ?? \"\" : \"\";\n\n    const pageUrl = isInIframe()\n      ? typeof document !== \"undefined\"\n        ? document?.referrer || windowHref\n        : windowHref\n      : windowHref;\n\n    const playerPrefix = currentState?.currentSource?.type ?? \"unknown\";\n    const version = currentState?.__device.version ?? \"unknown\";\n\n    this.currentMetrics = {\n      autoplay: currentState.__initialProps.autoPlay\n        ? \"autoplay\"\n        : currentState.__initialProps.preload === \"auto\"\n          ? \"preload-full\"\n          : currentState.__initialProps.preload === \"metadata\"\n            ? \"preload-metadata\"\n            : \"standard\",\n      duration: null,\n      firstPlayback: null,\n      nError: null,\n      nStalled: null,\n      nWaiting: null,\n      offset: null,\n      pageUrl,\n      playbackScore: null,\n      player: `${playerPrefix}-${version}`,\n      sourceType: currentState?.currentSource?.mime ?? \"unknown\",\n      sourceUrl: currentState?.currentSource?.src ?? null,\n      playerHeight: null,\n      playerWidth: null,\n      preloadTime: null,\n      timeStalled: 0,\n      timeUnpaused: 0,\n      timeWaiting: 0,\n      ttff: null,\n      uid: currentState.__initialProps.viewerId ?? \"\",\n      userAgent: String(currentState?.__device?.userAgent ?? \"\").replace(\n        /\\\\|\"/gm,\n        \"\",\n      ),\n      videoHeight: null,\n      videoWidth: null,\n    };\n\n    this.destroy = store.subscribe((state, prevState) => {\n      if (\n        this.requestedPlayTime === null &&\n        state.__controls.playLastTime !== 0\n      ) {\n        this.requestedPlayTime = Math.max(\n          state.__controls.playLastTime - bootMs,\n          0,\n        );\n      }\n\n      if (state.currentSource?.src !== prevState.currentSource?.src) {\n        const playerPrefix = state?.currentSource?.type ?? \"unknown\";\n        const version = state?.__device.version ?? \"unknown\";\n\n        this.currentMetrics.player = `${playerPrefix}-${version}`;\n        this.currentMetrics.sourceType = state.currentSource?.mime ?? \"unknown\";\n        this.currentMetrics.sourceUrl = state.currentSource?.src ?? null;\n      }\n\n      if (state.playing !== prevState.playing) {\n        if (state.playing) {\n          this.timeStalled.stop();\n          this.timeWaiting.stop();\n\n          this.timeUnpaused.start();\n        } else {\n          this.timeUnpaused.stop();\n          this.timeStalled.stop();\n          this.timeWaiting.stop();\n        }\n      }\n\n      if (\n        opts?.disableProgressListener !== true &&\n        state.progress !== prevState.progress &&\n        !this.timeUnpaused.startTime\n      ) {\n        this.timeStalled.stop();\n        this.timeWaiting.stop();\n        this.timeUnpaused.start();\n      }\n\n      if (state.stalled !== prevState.stalled) {\n        if (state.stalled) {\n          this.timeStalled.start();\n          this.timeUnpaused.stop();\n        } else if (state.playing) {\n          this.timeStalled.stop();\n          this.timeWaiting.stop();\n\n          this.timeUnpaused.start();\n        }\n      }\n      if (state.waiting !== prevState.waiting) {\n        if (state.waiting) {\n          this.timeWaiting.start();\n          this.timeUnpaused.stop();\n        } else if (state.playing) {\n          this.timeStalled.stop();\n          this.timeWaiting.stop();\n\n          this.timeUnpaused.start();\n        }\n      }\n    });\n  }\n\n  addError(error: string) {\n    this.currentMetrics.nError = (this.currentMetrics.nError ?? 0) + 1;\n    this.currentMetrics.lastError = error;\n  }\n\n  getFirstPlayback() {\n    return this.currentMetrics.firstPlayback;\n  }\n  setFirstPlayback() {\n    this.currentMetrics.firstPlayback = Date.now() - this.bootMs;\n  }\n  getFirstFrameTime() {\n    return this.firstFrameTime;\n  }\n  setFirstFrameTime() {\n    this.firstFrameTime = Date.now() - this.bootMs;\n  }\n  setPlaybackScore(playbackScore: number) {\n    this.currentMetrics.playbackScore = playbackScore;\n  }\n  setConnected(isConnected: boolean) {\n    this.connected = isConnected;\n  }\n\n  getMetrics() {\n    const currentMetrics: RawMetrics = {\n      ...this.currentMetrics,\n      playerHeight:\n        this.store.getState().__controls.size?.container?.height || null,\n      playerWidth:\n        this.store.getState().__controls.size?.container?.width || null,\n      videoWidth: this.store.getState().__controls.size?.media?.width || null,\n      videoHeight: this.store.getState().__controls.size?.media?.height || null,\n      duration: this.store.getState().duration || null,\n\n      nWaiting: this.timeWaiting.getCountStarts(),\n      nStalled: this.timeStalled.getCountStarts(),\n\n      timeWaiting: this.timeWaiting.getTotalTime(),\n      timeStalled: this.timeStalled.getTotalTime(),\n      timeUnpaused: this.timeUnpaused.getTotalTime(),\n\n      offset: this.store.getState().__controls.playbackOffsetMs || null,\n\n      // this is the amount of time that a video has had to preload content, from boot until play was requested\n      preloadTime: this.requestedPlayTime,\n      // time from when the first `play` event is emitted and the first progress update\n      ttff:\n        this.firstFrameTime &&\n        this.requestedPlayTime &&\n        this.firstFrameTime > 0 &&\n        this.requestedPlayTime > 0\n          ? Math.max(this.firstFrameTime - this.requestedPlayTime, 0)\n          : null,\n    };\n\n    const previousMetrics = this.previousMetrics;\n    this.previousMetrics = currentMetrics;\n\n    return {\n      current: currentMetrics,\n      previous: previousMetrics,\n    };\n  }\n}\n\nexport type MediaMetrics = {\n  metrics: MetricsStatus | null;\n  destroy: () => void;\n};\n\n/**\n * Gather playback metrics from a media store and\n * report them to a websocket. Automatically handles a redirect to get the\n * metrics endpoint.\n *\n * @param store Element to capture playback metrics from\n */\nexport function addMediaMetricsToStore(\n  store: MediaControllerStore | undefined | null,\n  opts?: MetricsOpts,\n): MediaMetrics {\n  const bootMs = Date.now(); // used for firstPlayback value\n\n  const defaultResponse: MediaMetrics = {\n    metrics: null,\n    destroy: () => {\n      //\n    },\n  };\n\n  if (!store) {\n    return defaultResponse;\n  }\n\n  if (!WebSocket) {\n    console.log(\"Environment does not support WebSocket\");\n    return defaultResponse;\n  }\n\n  let websocketPromise: Promise<WebSocket | null> | null = null;\n\n  let timeOut: NodeJS.Timeout | null = null;\n  let enabled = true;\n\n  const metricsStatus = new MetricsStatus(store, bootMs, opts);\n  const monitor = new PlaybackMonitor(store);\n\n  const report = async () => {\n    const ws = await websocketPromise;\n\n    if (!enabled || !ws) {\n      return;\n    }\n\n    // update playback score from monitor\n    const playbackScore = monitor.calculateScore();\n    if (playbackScore !== null) {\n      metricsStatus.setPlaybackScore(playbackScore);\n    }\n\n    const metrics = metricsStatus.getMetrics();\n\n    // only send a report if stats have changed, and only send those changes\n    const d: Partial<RawMetrics> = {};\n    let key: keyof RawMetrics;\n    for (key in metrics.current) {\n      const val = metrics.current[key];\n\n      const shouldSendValue =\n        typeof val === \"number\"\n          ? Number.isFinite(val) && !Number.isNaN(val) && val >= 0\n          : Boolean(val);\n\n      if (shouldSendValue && val !== metrics?.previous?.[key]) {\n        (d[key] as typeof val) = val;\n      }\n    }\n    if (Object.keys(d).length > 0) {\n      send(ws, d);\n    }\n\n    timeOut = setTimeout(() => {\n      report();\n    }, 1e3);\n  };\n\n  const createNewWebSocket = async (\n    playbackId: string,\n    currentSource: string,\n    numRetries = 0,\n  ) => {\n    try {\n      if (!playbackId || !currentSource) {\n        return null;\n      }\n\n      const prevWebsocket = await websocketPromise;\n\n      prevWebsocket?.close?.(3077);\n\n      const reportingWebsocketUrl = await getMetricsReportingUrl(\n        playbackId,\n        currentSource,\n        store.getState().__controls.sessionToken,\n      );\n\n      if (reportingWebsocketUrl) {\n        const newWebSocket = new WebSocket(reportingWebsocketUrl);\n\n        newWebSocket.addEventListener(\"open\", async () => {\n          // enable active statistics reporting\n          report();\n        });\n        newWebSocket.addEventListener(\"message\", (event) => {\n          try {\n            if (event?.data) {\n              const json = JSON.parse(event.data);\n\n              if (json?.meta?.bframes || json?.meta?.buffer_window) {\n                store.getState().__controlsFunctions.setWebsocketMetadata({\n                  bframes: json?.meta?.bframes\n                    ? Number(json?.meta?.bframes)\n                    : undefined,\n                  bufferWindow: json?.meta?.buffer_window\n                    ? Number(json?.meta?.buffer_window)\n                    : undefined,\n                });\n              }\n            }\n          } catch (e) {\n            console.warn(\"Failed to parse metadata from websocket.\");\n          }\n        });\n        newWebSocket.addEventListener(\"close\", () => {\n          // disable active statistics gathering\n          if (timeOut) {\n            clearTimeout(timeOut);\n            timeOut = null;\n            enabled = false;\n          }\n\n          // auto-reconnect with exponential backoff\n          setTimeout(\n            () => {\n              if (enabled) {\n                websocketPromise = createNewWebSocket(\n                  playbackId,\n                  currentSource,\n                  numRetries + 1,\n                );\n              }\n            },\n            2 ** numRetries * 1e3,\n          );\n        });\n        return newWebSocket;\n      }\n    } catch (e) {\n      console.error(e);\n      store.getState().__controlsFunctions.onError?.(e as Error);\n    }\n\n    return null;\n  };\n\n  const destroyMetricsListener = store.subscribe(\n    (state) => ({\n      playbackId: state.__controls.playbackId,\n      finalUrl: state.currentUrl,\n      type: state.currentSource?.type,\n    }),\n    (state) => {\n      if (state?.playbackId && state?.finalUrl) {\n        websocketPromise = createNewWebSocket(state.playbackId, state.finalUrl);\n      }\n    },\n    {\n      fireImmediately: true,\n      equalityFn: (a, b) => {\n        return (\n          a.type === b.type &&\n          a.playbackId === b.playbackId &&\n          Boolean(a.finalUrl)\n        );\n      },\n    },\n  );\n\n  try {\n    const destroyTtffListener = store.subscribe((state, prevState) => {\n      if (\n        state.playing !== prevState.playing &&\n        metricsStatus.getFirstPlayback() === null\n      ) {\n        metricsStatus.setFirstPlayback();\n      }\n\n      if (\n        state.progress !== prevState.progress &&\n        metricsStatus.getFirstFrameTime() === null\n      ) {\n        metricsStatus.setFirstFrameTime();\n      }\n\n      if (\n        state.error?.message &&\n        state.error?.message !== prevState.error?.message\n      ) {\n        metricsStatus.addError(state.error.message);\n      }\n    });\n\n    const destroyMonitorListener = store.subscribe((state, prevState) => {\n      // enable\n      if (\n        (state.playing !== prevState.playing && state.playing) ||\n        (state.loading !== prevState.loading && state.loading)\n      ) {\n        monitor.init();\n      }\n\n      if (\n        state.__controls.requestedRangeToSeekTo !==\n        prevState.__controls.requestedRangeToSeekTo\n      ) {\n        monitor.reset();\n      }\n\n      if (state.playing !== prevState.playing && !state.playing) {\n        monitor.destroy();\n      }\n    });\n\n    const destroy = () => {\n      enabled = false;\n\n      destroyMetricsListener?.();\n      destroyMonitorListener?.();\n      destroyTtffListener?.();\n\n      monitor?.destroy?.();\n      metricsStatus?.destroy?.();\n\n      if (timeOut) {\n        clearTimeout(timeOut);\n      }\n\n      if (websocketPromise) {\n        websocketPromise.then((websocket) => {\n          websocket?.close(3077);\n        });\n      }\n    };\n\n    return { metrics: metricsStatus, destroy };\n  } catch (e) {\n    console.error(e);\n  }\n\n  return defaultResponse;\n}\n\nfunction send(webSocket: WebSocket, metrics: Partial<RawMetrics>) {\n  if (webSocket.readyState !== webSocket.OPEN) {\n    return;\n  }\n\n  webSocket.send(JSON.stringify(metrics));\n}\n"],"mappings":"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","names":["minutes","src","playerPrefix","version"]}