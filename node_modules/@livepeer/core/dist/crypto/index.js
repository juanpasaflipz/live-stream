// src/utils/string.ts
var b64Encode = (input) => {
  try {
    if (typeof window !== "undefined" && "btoa" in window) {
      return window?.btoa?.(input) ?? null;
    }
    return Buffer?.from(input, "binary")?.toString("base64") ?? null;
  } catch (e) {
    return null;
  }
};
var b64Decode = (input) => {
  try {
    if (typeof window !== "undefined" && "atob" in window) {
      return window?.atob?.(input) ?? null;
    }
    return Buffer?.from(input, "base64")?.toString("binary") ?? null;
  } catch (e) {
    return null;
  }
};
var b64UrlEncode = (input) => {
  return escapeInput(b64Encode(input));
};
var b64UrlDecode = (input) => {
  const unescaped = unescapeInput(input);
  if (unescaped) {
    return b64Decode(unescaped);
  }
  return null;
};
var unescapeInput = (input) => {
  return input ? (input + "===".slice((input.length + 3) % 4)).replace(/-/g, "+").replace(/_/g, "/") : null;
};
var escapeInput = (input) => {
  return input?.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "") ?? null;
};

// src/crypto/getSubtleCrypto.ts
var getSubtleCrypto = async () => {
  if (typeof crypto !== "undefined" && crypto?.subtle) {
    return crypto.subtle;
  }
  if (typeof globalThis?.crypto !== "undefined" && globalThis?.crypto?.subtle) {
    return globalThis.crypto.subtle;
  }
  try {
    const nodeCrypto = await import("node:crypto");
    return nodeCrypto.webcrypto.subtle;
  } catch (error) {
    if (typeof window !== "undefined") {
      if (window?.crypto?.subtle) {
        return window.crypto.subtle;
      }
      throw new Error(
        "Browser is not in a secure context (HTTPS), cannot use SubtleCrypto: https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto"
      );
    }
    throw new Error(
      `Failed to import Node.js crypto module: ${error?.message ?? ""}`
    );
  }
};

// src/crypto/ecdsa.ts
var signEcdsaSha256 = async (privateKey, data) => {
  const subtleCrypto = await getSubtleCrypto();
  return subtleCrypto.sign(
    {
      name: "ECDSA",
      hash: { name: "SHA-256" }
    },
    privateKey,
    data
  );
};

// src/crypto/pkcs8.ts
var importPKCS8 = async (pkcs8) => {
  if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
    throw new TypeError('"pkcs8" must be PKCS8 formatted string');
  }
  const privateKeyContents = b64UrlDecode(
    pkcs8.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, "")
  );
  if (!privateKeyContents) {
    throw new TypeError("Could not base64 decode private key contents.");
  }
  const subtleCrypto = await getSubtleCrypto();
  return subtleCrypto.importKey(
    "pkcs8",
    new Uint8Array(privateKeyContents?.split("").map((c) => c.charCodeAt(0))),
    {
      name: "ECDSA",
      namedCurve: "P-256"
    },
    false,
    ["sign"]
  );
};

// src/crypto/jwt.ts
var signAccessJwt = async (options) => {
  const privateKey = typeof options.privateKey === "string" ? await importPKCS8(b64Decode(options.privateKey) ?? options.privateKey) : options.privateKey;
  if (!privateKey) {
    throw new Error("Error importing private key.");
  }
  const issuedAtSec = Date.now() / 1e3;
  const expirationSec = issuedAtSec + (options.expiration ?? 86400);
  const payload = {
    action: "pull",
    iss: options.issuer,
    pub: options.publicKey,
    sub: options.playbackId,
    video: "none",
    exp: Number(expirationSec.toFixed(0)),
    iat: Number(issuedAtSec.toFixed(0)),
    ...options.custom ? {
      custom: {
        ...options.custom
      }
    } : {}
  };
  const header = {
    alg: "ES256",
    typ: "JWT"
  };
  const base64Header = b64UrlEncode(JSON.stringify(header));
  const base64Payload = b64UrlEncode(JSON.stringify(payload));
  const body = `${base64Header}.${base64Payload}`;
  const signatureBuffer = await signEcdsaSha256(privateKey, Buffer.from(body));
  const signature = b64UrlEncode(
    String.fromCharCode(...new Uint8Array(signatureBuffer))
  );
  return `${base64Header}.${base64Payload}.${signature}`;
};
export {
  importPKCS8,
  signAccessJwt
};
//# sourceMappingURL=index.js.map