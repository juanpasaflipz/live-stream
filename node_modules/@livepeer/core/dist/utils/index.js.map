{"version":3,"sources":["../../src/utils/deepMerge.ts","../../src/utils/omick.ts","../../src/utils/storage/arweave.ts","../../src/utils/storage/ipfs.ts","../../src/utils/string.ts","../../src/utils/types.ts","../../src/utils/warn.ts"],"sourcesContent":["// from https://github.com/voodoocreation/ts-deepmerge/blob/master/src/index.ts\ninterface IObject {\n  // biome-ignore lint/suspicious/noExplicitAny: any\n  [key: string]: any;\n}\n\ntype TUnionToIntersection<U> =\n  // biome-ignore lint/suspicious/noExplicitAny: any\n  (U extends any ? (k: U) => void : never) extends (k: infer I) => void\n    ? I\n    : never;\n\n// biome-ignore lint/suspicious/noExplicitAny: any\nconst isObject = (obj: any) => {\n  if (typeof obj === \"object\" && obj !== null) {\n    if (typeof Object.getPrototypeOf === \"function\") {\n      const prototype = Object.getPrototypeOf(obj);\n      return prototype === Object.prototype || prototype === null;\n    }\n\n    return Object.prototype.toString.call(obj) === \"[object Object]\";\n  }\n\n  return false;\n};\n\nconst merge = <T extends IObject[]>(\n  ...objects: T\n): TUnionToIntersection<T[number]> =>\n  objects.reduce((result, current) => {\n    if (Array.isArray(current)) {\n      throw new TypeError(\n        \"Arguments provided to ts-deepmerge must be objects, not arrays.\",\n      );\n    }\n\n    // biome-ignore lint/complexity/noForEach: <explanation>\n    Object.keys(current).forEach((key) => {\n      if ([\"__proto__\", \"constructor\", \"prototype\"].includes(key)) {\n        return;\n      }\n\n      if (Array.isArray(result[key]) && Array.isArray(current[key])) {\n        result[key] = merge.options.mergeArrays\n          ? Array.from(new Set((result[key] as unknown[]).concat(current[key])))\n          : current[key];\n      } else if (isObject(result[key]) && isObject(current[key])) {\n        result[key] = merge(result[key] as IObject, current[key] as IObject);\n      } else {\n        result[key] = current[key];\n      }\n    });\n\n    return result;\n    // biome-ignore lint/suspicious/noExplicitAny: any\n  }, {}) as any;\n\nexport interface DeepMergeOptions {\n  mergeArrays: boolean;\n}\n\nconst defaultOptions: DeepMergeOptions = {\n  mergeArrays: true,\n};\n\nmerge.options = defaultOptions;\n\nmerge.withOptions = <T extends IObject[]>(\n  options: Partial<DeepMergeOptions>,\n  ...objects: T\n) => {\n  merge.options = {\n    mergeArrays: true,\n    ...options,\n  };\n\n  const result = merge(...objects);\n\n  merge.options = defaultOptions;\n\n  return result;\n};\n\nexport const deepMerge = merge;\n","/**\n * Create a new object containing only the specified keys\n */\nexport const pick = <T extends object, K extends keyof T>(\n  obj: T,\n  ...keys: readonly K[]\n): Pick<T, K> => {\n  try {\n    const objectKeys = Object.keys(obj);\n\n    return keys\n      .filter((key) => objectKeys.includes(key as string))\n      .reduce(\n        (prev, curr) => ({\n          // biome-ignore lint/performance/noAccumulatingSpread: <explanation>\n          ...prev,\n          [curr]: obj[curr],\n        }),\n        {},\n      ) as Pick<T, K>;\n  } catch (e) {\n    throw new Error(\"Could not pick keys for object.\");\n  }\n};\n\n/**\n * Create a new object excluding the specified keys\n */\nexport function omit<T extends object, K extends keyof T>(\n  obj: T,\n  ...keys: readonly K[]\n): Omit<T, K> {\n  try {\n    const objectKeys = Object.keys(obj);\n\n    return objectKeys\n      .filter((objectKey) => !keys.some((key) => String(key) === objectKey))\n      .reduce(\n        (prev, curr) => ({\n          // biome-ignore lint/performance/noAccumulatingSpread: <explanation>\n          ...prev,\n          [curr]: obj[curr as K],\n        }),\n        {},\n      ) as Omit<T, K>;\n  } catch (e) {\n    throw new Error(\"Could not omit keys for object.\");\n  }\n}\n","// Arweave Protocol\nconst arweaveProtocolPattern = /^(ar):\\/\\/([^/?#]+)(.*)$/;\n\n// Gateways\nconst pathGatewayPattern =\n  /^https:\\/\\/(arweave\\.net|arweave\\.dev)\\/([^/?#]+)(.*)$/;\nconst subdomainGatewayPattern =\n  /^https:\\/\\/([^/]+)\\.(arweave\\.net|arweave\\.dev)\\/([^/?#]+)(.*)$/;\n\n/**\n * Takes an Arweave URL and returns a formatted Arweave URL if it is valid.\n * _This does not allow paths, query params, or hash in the URL and will return null_.\n * It does not check if the hash is a correct base64 URL encoded SHA-256 hash\n *\n * @param possibleArweaveString A possible URL for an Arweave resource. Can be a gateway or Arweave protocol URL.\n * @returns The formatted Arweave URI with `ar://` protocol and hash. Returns null if the URL is not valid.\n */\nexport const parseArweaveTxId = (\n  possibleArweaveString: string | null | undefined,\n) => {\n  if (!possibleArweaveString) {\n    return null;\n  }\n\n  const arweaveProtocolHash = possibleArweaveString.match(\n    arweaveProtocolPattern,\n  )?.[2];\n  const arweaveProtocolUrlIndicators = possibleArweaveString.match(\n    arweaveProtocolPattern,\n  )?.[3];\n\n  if (arweaveProtocolHash) {\n    return formatReturnHash(arweaveProtocolHash, arweaveProtocolUrlIndicators);\n  }\n\n  const subdomainGatewayHash = possibleArweaveString.match(\n    subdomainGatewayPattern,\n  )?.[3];\n  const subdomainGatewayUrlIndicators = possibleArweaveString.match(\n    subdomainGatewayPattern,\n  )?.[4];\n\n  if (subdomainGatewayHash) {\n    return formatReturnHash(\n      subdomainGatewayHash,\n      subdomainGatewayUrlIndicators,\n    );\n  }\n\n  const pathGatewayHash = possibleArweaveString.match(pathGatewayPattern)?.[2];\n  const pathGatewayUrlIndicators =\n    possibleArweaveString.match(pathGatewayPattern)?.[3];\n\n  if (pathGatewayHash) {\n    return formatReturnHash(pathGatewayHash, pathGatewayUrlIndicators);\n  }\n\n  return null;\n};\n\nconst formatReturnHash = (hash: string, urlIndicators?: string) => {\n  const hashWithUrlIndicators = `${hash}${urlIndicators ?? \"\"}`;\n  return {\n    url: `ar://${hashWithUrlIndicators}`,\n    id: hashWithUrlIndicators,\n  };\n};\n","import { CID } from \"multiformats/cid\";\n\n// IPFS CID (naive check for lack of URL indicators)\nconst ipfsCidPattern = /^([^/?#]+)$/;\n\n// IPFS Protocol\nconst ipfsProtocolPattern = /^(ipfs):\\/\\/([^/?#]+)(.*)$/;\n\n// Gateways\nconst pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ipfs)\\/([^/?#]+)(.*)$/;\nconst subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ipfs)\\.[^/?#]+(.*)$/;\n\n/**\n * Takes an IPFS CID or URL and returns a formatted IPFS URL if the CID/URL is valid.\n * _This does not allow paths, query params, or hash in the URL and will return null_.\n *\n * @param possibleIpfsString A possible URL for an IPFS resource. Can be a gateway or IPFS protocol URL.\n * @returns The formatted IPFS URI with protocol and CID. Returns null if the URL is not valid.\n */\nexport const parseCid = (possibleIpfsString: string | null | undefined) => {\n  if (!possibleIpfsString) {\n    return null;\n  }\n\n  const ipfsProtocolCid = possibleIpfsString.match(ipfsProtocolPattern)?.[2];\n  const ipfsProtocolUrlIndicators =\n    possibleIpfsString.match(ipfsProtocolPattern)?.[3];\n\n  if (isCid(ipfsProtocolCid)) {\n    return formatReturnCid(ipfsProtocolCid, ipfsProtocolUrlIndicators);\n  }\n\n  const subdomainGatewayCid = possibleIpfsString.match(\n    subdomainGatewayPattern,\n  )?.[1];\n  const subdomainGatewayUrlIndicators = possibleIpfsString.match(\n    subdomainGatewayPattern,\n  )?.[3];\n\n  if (isCid(subdomainGatewayCid)) {\n    return formatReturnCid(subdomainGatewayCid, subdomainGatewayUrlIndicators);\n  }\n\n  const pathGatewayCid = possibleIpfsString.match(pathGatewayPattern)?.[2];\n  const pathGatewayUrlIndicators =\n    possibleIpfsString.match(pathGatewayPattern)?.[3];\n\n  if (isCid(pathGatewayCid)) {\n    return formatReturnCid(pathGatewayCid, pathGatewayUrlIndicators);\n  }\n\n  const ipfsCid = possibleIpfsString.match(ipfsCidPattern)?.[1];\n\n  if (isCid(ipfsCid)) {\n    return formatReturnCid(ipfsCid);\n  }\n\n  return null;\n};\n\nconst isCid = (\n  hash: CID | Uint8Array | string | undefined | null,\n): hash is CID => {\n  try {\n    if (!hash) {\n      return false;\n    }\n\n    if (typeof hash === \"string\") {\n      return Boolean(CID.parse(hash));\n    }\n\n    if (hash instanceof Uint8Array) {\n      return Boolean(CID.decode(hash));\n    }\n\n    return Boolean(CID.asCID(hash));\n  } catch {\n    return false;\n  }\n};\n\nconst formatReturnCid = (cid: string, urlIndicators?: string) => {\n  const cidWithUrlIndicators = `${cid}${urlIndicators ?? \"\"}`;\n  return {\n    url: `ipfs://${cidWithUrlIndicators}`,\n    id: cidWithUrlIndicators,\n  };\n};\n","export const b64Encode = (input: string): string | null => {\n  try {\n    if (typeof window !== \"undefined\" && \"btoa\" in window) {\n      return window?.btoa?.(input) ?? null;\n    }\n    return Buffer?.from(input, \"binary\")?.toString(\"base64\") ?? null;\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const b64Decode = (input: string): string | null => {\n  try {\n    if (typeof window !== \"undefined\" && \"atob\" in window) {\n      return window?.atob?.(input) ?? null;\n    }\n    return Buffer?.from(input, \"base64\")?.toString(\"binary\") ?? null;\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const b64UrlEncode = (input: string): string | null => {\n  return escapeInput(b64Encode(input));\n};\n\nexport const b64UrlDecode = (input: string): string | null => {\n  const unescaped = unescapeInput(input);\n  if (unescaped) {\n    return b64Decode(unescaped);\n  }\n  return null;\n};\n\nconst unescapeInput = (input: string | undefined | null) => {\n  return input\n    ? (input + \"===\".slice((input.length + 3) % 4))\n        .replace(/-/g, \"+\")\n        .replace(/_/g, \"/\")\n    : null;\n};\n\nconst escapeInput = (input: string | undefined | null) => {\n  return (\n    input?.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\") ?? null\n  );\n};\n","// biome-ignore lint/suspicious/noExplicitAny: any\nexport const noop = (..._args: any[]) => {\n  //\n};\n","const cache = new Set<string>();\n\nexport function warn(message: string, id?: string) {\n  if (!cache.has(id ?? message)) {\n    console.warn(message);\n    cache.add(message);\n  }\n}\n"],"mappings":";AAaA,IAAM,WAAW,CAAC,QAAa;AAC7B,MAAI,OAAO,QAAQ,YAAY,QAAQ,MAAM;AAC3C,QAAI,OAAO,OAAO,mBAAmB,YAAY;AAC/C,YAAM,YAAY,OAAO,eAAe,GAAG;AAC3C,aAAO,cAAc,OAAO,aAAa,cAAc;AAAA,IACzD;AAEA,WAAO,OAAO,UAAU,SAAS,KAAK,GAAG,MAAM;AAAA,EACjD;AAEA,SAAO;AACT;AAEA,IAAM,QAAQ,IACT,YAEH,QAAQ,OAAO,CAAC,QAAQ,YAAY;AAClC,MAAI,MAAM,QAAQ,OAAO,GAAG;AAC1B,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAGA,SAAO,KAAK,OAAO,EAAE,QAAQ,CAAC,QAAQ;AACpC,QAAI,CAAC,aAAa,eAAe,WAAW,EAAE,SAAS,GAAG,GAAG;AAC3D;AAAA,IACF;AAEA,QAAI,MAAM,QAAQ,OAAO,GAAG,CAAC,KAAK,MAAM,QAAQ,QAAQ,GAAG,CAAC,GAAG;AAC7D,aAAO,GAAG,IAAI,MAAM,QAAQ,cACxB,MAAM,KAAK,IAAI,IAAK,OAAO,GAAG,EAAgB,OAAO,QAAQ,GAAG,CAAC,CAAC,CAAC,IACnE,QAAQ,GAAG;AAAA,IACjB,WAAW,SAAS,OAAO,GAAG,CAAC,KAAK,SAAS,QAAQ,GAAG,CAAC,GAAG;AAC1D,aAAO,GAAG,IAAI,MAAM,OAAO,GAAG,GAAc,QAAQ,GAAG,CAAY;AAAA,IACrE,OAAO;AACL,aAAO,GAAG,IAAI,QAAQ,GAAG;AAAA,IAC3B;AAAA,EACF,CAAC;AAED,SAAO;AAET,GAAG,CAAC,CAAC;AAMP,IAAM,iBAAmC;AAAA,EACvC,aAAa;AACf;AAEA,MAAM,UAAU;AAEhB,MAAM,cAAc,CAClB,YACG,YACA;AACH,QAAM,UAAU;AAAA,IACd,aAAa;AAAA,IACb,GAAG;AAAA,EACL;AAEA,QAAM,SAAS,MAAM,GAAG,OAAO;AAE/B,QAAM,UAAU;AAEhB,SAAO;AACT;AAEO,IAAM,YAAY;;;AChFlB,IAAM,OAAO,CAClB,QACG,SACY;AACf,MAAI;AACF,UAAM,aAAa,OAAO,KAAK,GAAG;AAElC,WAAO,KACJ,OAAO,CAAC,QAAQ,WAAW,SAAS,GAAa,CAAC,EAClD;AAAA,MACC,CAAC,MAAM,UAAU;AAAA;AAAA,QAEf,GAAG;AAAA,QACH,CAAC,IAAI,GAAG,IAAI,IAAI;AAAA,MAClB;AAAA,MACA,CAAC;AAAA,IACH;AAAA,EACJ,SAAS,GAAG;AACV,UAAM,IAAI,MAAM,iCAAiC;AAAA,EACnD;AACF;AAKO,SAAS,KACd,QACG,MACS;AACZ,MAAI;AACF,UAAM,aAAa,OAAO,KAAK,GAAG;AAElC,WAAO,WACJ,OAAO,CAAC,cAAc,CAAC,KAAK,KAAK,CAAC,QAAQ,OAAO,GAAG,MAAM,SAAS,CAAC,EACpE;AAAA,MACC,CAAC,MAAM,UAAU;AAAA;AAAA,QAEf,GAAG;AAAA,QACH,CAAC,IAAI,GAAG,IAAI,IAAS;AAAA,MACvB;AAAA,MACA,CAAC;AAAA,IACH;AAAA,EACJ,SAAS,GAAG;AACV,UAAM,IAAI,MAAM,iCAAiC;AAAA,EACnD;AACF;;;AC/CA,IAAM,yBAAyB;AAG/B,IAAM,qBACJ;AACF,IAAM,0BACJ;AAUK,IAAM,mBAAmB,CAC9B,0BACG;AACH,MAAI,CAAC,uBAAuB;AAC1B,WAAO;AAAA,EACT;AAEA,QAAM,sBAAsB,sBAAsB;AAAA,IAChD;AAAA,EACF,IAAI,CAAC;AACL,QAAM,+BAA+B,sBAAsB;AAAA,IACzD;AAAA,EACF,IAAI,CAAC;AAEL,MAAI,qBAAqB;AACvB,WAAO,iBAAiB,qBAAqB,4BAA4B;AAAA,EAC3E;AAEA,QAAM,uBAAuB,sBAAsB;AAAA,IACjD;AAAA,EACF,IAAI,CAAC;AACL,QAAM,gCAAgC,sBAAsB;AAAA,IAC1D;AAAA,EACF,IAAI,CAAC;AAEL,MAAI,sBAAsB;AACxB,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,QAAM,kBAAkB,sBAAsB,MAAM,kBAAkB,IAAI,CAAC;AAC3E,QAAM,2BACJ,sBAAsB,MAAM,kBAAkB,IAAI,CAAC;AAErD,MAAI,iBAAiB;AACnB,WAAO,iBAAiB,iBAAiB,wBAAwB;AAAA,EACnE;AAEA,SAAO;AACT;AAEA,IAAM,mBAAmB,CAAC,MAAc,kBAA2B;AACjE,QAAM,wBAAwB,GAAG,IAAI,GAAG,iBAAiB,EAAE;AAC3D,SAAO;AAAA,IACL,KAAK,QAAQ,qBAAqB;AAAA,IAClC,IAAI;AAAA,EACN;AACF;;;AClEA,SAAS,WAAW;AAGpB,IAAM,iBAAiB;AAGvB,IAAM,sBAAsB;AAG5B,IAAMA,sBAAqB;AAC3B,IAAMC,2BAA0B;AASzB,IAAM,WAAW,CAAC,uBAAkD;AACzE,MAAI,CAAC,oBAAoB;AACvB,WAAO;AAAA,EACT;AAEA,QAAM,kBAAkB,mBAAmB,MAAM,mBAAmB,IAAI,CAAC;AACzE,QAAM,4BACJ,mBAAmB,MAAM,mBAAmB,IAAI,CAAC;AAEnD,MAAI,MAAM,eAAe,GAAG;AAC1B,WAAO,gBAAgB,iBAAiB,yBAAyB;AAAA,EACnE;AAEA,QAAM,sBAAsB,mBAAmB;AAAA,IAC7CA;AAAA,EACF,IAAI,CAAC;AACL,QAAM,gCAAgC,mBAAmB;AAAA,IACvDA;AAAA,EACF,IAAI,CAAC;AAEL,MAAI,MAAM,mBAAmB,GAAG;AAC9B,WAAO,gBAAgB,qBAAqB,6BAA6B;AAAA,EAC3E;AAEA,QAAM,iBAAiB,mBAAmB,MAAMD,mBAAkB,IAAI,CAAC;AACvE,QAAM,2BACJ,mBAAmB,MAAMA,mBAAkB,IAAI,CAAC;AAElD,MAAI,MAAM,cAAc,GAAG;AACzB,WAAO,gBAAgB,gBAAgB,wBAAwB;AAAA,EACjE;AAEA,QAAM,UAAU,mBAAmB,MAAM,cAAc,IAAI,CAAC;AAE5D,MAAI,MAAM,OAAO,GAAG;AAClB,WAAO,gBAAgB,OAAO;AAAA,EAChC;AAEA,SAAO;AACT;AAEA,IAAM,QAAQ,CACZ,SACgB;AAChB,MAAI;AACF,QAAI,CAAC,MAAM;AACT,aAAO;AAAA,IACT;AAEA,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,QAAQ,IAAI,MAAM,IAAI,CAAC;AAAA,IAChC;AAEA,QAAI,gBAAgB,YAAY;AAC9B,aAAO,QAAQ,IAAI,OAAO,IAAI,CAAC;AAAA,IACjC;AAEA,WAAO,QAAQ,IAAI,MAAM,IAAI,CAAC;AAAA,EAChC,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEA,IAAM,kBAAkB,CAAC,KAAa,kBAA2B;AAC/D,QAAM,uBAAuB,GAAG,GAAG,GAAG,iBAAiB,EAAE;AACzD,SAAO;AAAA,IACL,KAAK,UAAU,oBAAoB;AAAA,IACnC,IAAI;AAAA,EACN;AACF;;;ACxFO,IAAM,YAAY,CAAC,UAAiC;AACzD,MAAI;AACF,QAAI,OAAO,WAAW,eAAe,UAAU,QAAQ;AACrD,aAAO,QAAQ,OAAO,KAAK,KAAK;AAAA,IAClC;AACA,WAAO,QAAQ,KAAK,OAAO,QAAQ,GAAG,SAAS,QAAQ,KAAK;AAAA,EAC9D,SAAS,GAAG;AACV,WAAO;AAAA,EACT;AACF;AAEO,IAAM,YAAY,CAAC,UAAiC;AACzD,MAAI;AACF,QAAI,OAAO,WAAW,eAAe,UAAU,QAAQ;AACrD,aAAO,QAAQ,OAAO,KAAK,KAAK;AAAA,IAClC;AACA,WAAO,QAAQ,KAAK,OAAO,QAAQ,GAAG,SAAS,QAAQ,KAAK;AAAA,EAC9D,SAAS,GAAG;AACV,WAAO;AAAA,EACT;AACF;AAEO,IAAM,eAAe,CAAC,UAAiC;AAC5D,SAAO,YAAY,UAAU,KAAK,CAAC;AACrC;AAEO,IAAM,eAAe,CAAC,UAAiC;AAC5D,QAAM,YAAY,cAAc,KAAK;AACrC,MAAI,WAAW;AACb,WAAO,UAAU,SAAS;AAAA,EAC5B;AACA,SAAO;AACT;AAEA,IAAM,gBAAgB,CAAC,UAAqC;AAC1D,SAAO,SACF,QAAQ,MAAM,OAAO,MAAM,SAAS,KAAK,CAAC,GACxC,QAAQ,MAAM,GAAG,EACjB,QAAQ,MAAM,GAAG,IACpB;AACN;AAEA,IAAM,cAAc,CAAC,UAAqC;AACxD,SACE,OAAO,QAAQ,OAAO,GAAG,EAAE,QAAQ,OAAO,GAAG,EAAE,QAAQ,MAAM,EAAE,KAAK;AAExE;;;AC7CO,IAAM,OAAO,IAAI,UAAiB;AAEzC;;;ACHA,IAAM,QAAQ,oBAAI,IAAY;AAEvB,SAAS,KAAK,SAAiB,IAAa;AACjD,MAAI,CAAC,MAAM,IAAI,MAAM,OAAO,GAAG;AAC7B,YAAQ,KAAK,OAAO;AACpB,UAAM,IAAI,OAAO;AAAA,EACnB;AACF;","names":["pathGatewayPattern","subdomainGatewayPattern"]}