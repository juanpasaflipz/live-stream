// src/utils/deepMerge.ts
var isObject = (obj) => {
  if (typeof obj === "object" && obj !== null) {
    if (typeof Object.getPrototypeOf === "function") {
      const prototype = Object.getPrototypeOf(obj);
      return prototype === Object.prototype || prototype === null;
    }
    return Object.prototype.toString.call(obj) === "[object Object]";
  }
  return false;
};
var merge = (...objects) => objects.reduce((result, current) => {
  if (Array.isArray(current)) {
    throw new TypeError(
      "Arguments provided to ts-deepmerge must be objects, not arrays."
    );
  }
  Object.keys(current).forEach((key) => {
    if (["__proto__", "constructor", "prototype"].includes(key)) {
      return;
    }
    if (Array.isArray(result[key]) && Array.isArray(current[key])) {
      result[key] = merge.options.mergeArrays ? Array.from(new Set(result[key].concat(current[key]))) : current[key];
    } else if (isObject(result[key]) && isObject(current[key])) {
      result[key] = merge(result[key], current[key]);
    } else {
      result[key] = current[key];
    }
  });
  return result;
}, {});
var defaultOptions = {
  mergeArrays: true
};
merge.options = defaultOptions;
merge.withOptions = (options, ...objects) => {
  merge.options = {
    mergeArrays: true,
    ...options
  };
  const result = merge(...objects);
  merge.options = defaultOptions;
  return result;
};
var deepMerge = merge;

// src/utils/omick.ts
var pick = (obj, ...keys) => {
  try {
    const objectKeys = Object.keys(obj);
    return keys.filter((key) => objectKeys.includes(key)).reduce(
      (prev, curr) => ({
        // biome-ignore lint/performance/noAccumulatingSpread: <explanation>
        ...prev,
        [curr]: obj[curr]
      }),
      {}
    );
  } catch (e) {
    throw new Error("Could not pick keys for object.");
  }
};
function omit(obj, ...keys) {
  try {
    const objectKeys = Object.keys(obj);
    return objectKeys.filter((objectKey) => !keys.some((key) => String(key) === objectKey)).reduce(
      (prev, curr) => ({
        // biome-ignore lint/performance/noAccumulatingSpread: <explanation>
        ...prev,
        [curr]: obj[curr]
      }),
      {}
    );
  } catch (e) {
    throw new Error("Could not omit keys for object.");
  }
}

// src/utils/storage/arweave.ts
var arweaveProtocolPattern = /^(ar):\/\/([^/?#]+)(.*)$/;
var pathGatewayPattern = /^https:\/\/(arweave\.net|arweave\.dev)\/([^/?#]+)(.*)$/;
var subdomainGatewayPattern = /^https:\/\/([^/]+)\.(arweave\.net|arweave\.dev)\/([^/?#]+)(.*)$/;
var parseArweaveTxId = (possibleArweaveString) => {
  if (!possibleArweaveString) {
    return null;
  }
  const arweaveProtocolHash = possibleArweaveString.match(
    arweaveProtocolPattern
  )?.[2];
  const arweaveProtocolUrlIndicators = possibleArweaveString.match(
    arweaveProtocolPattern
  )?.[3];
  if (arweaveProtocolHash) {
    return formatReturnHash(arweaveProtocolHash, arweaveProtocolUrlIndicators);
  }
  const subdomainGatewayHash = possibleArweaveString.match(
    subdomainGatewayPattern
  )?.[3];
  const subdomainGatewayUrlIndicators = possibleArweaveString.match(
    subdomainGatewayPattern
  )?.[4];
  if (subdomainGatewayHash) {
    return formatReturnHash(
      subdomainGatewayHash,
      subdomainGatewayUrlIndicators
    );
  }
  const pathGatewayHash = possibleArweaveString.match(pathGatewayPattern)?.[2];
  const pathGatewayUrlIndicators = possibleArweaveString.match(pathGatewayPattern)?.[3];
  if (pathGatewayHash) {
    return formatReturnHash(pathGatewayHash, pathGatewayUrlIndicators);
  }
  return null;
};
var formatReturnHash = (hash, urlIndicators) => {
  const hashWithUrlIndicators = `${hash}${urlIndicators ?? ""}`;
  return {
    url: `ar://${hashWithUrlIndicators}`,
    id: hashWithUrlIndicators
  };
};

// src/utils/storage/ipfs.ts
import { CID } from "multiformats/cid";
var ipfsCidPattern = /^([^/?#]+)$/;
var ipfsProtocolPattern = /^(ipfs):\/\/([^/?#]+)(.*)$/;
var pathGatewayPattern2 = /^https?:\/\/[^/]+\/(ipfs)\/([^/?#]+)(.*)$/;
var subdomainGatewayPattern2 = /^https?:\/\/([^/]+)\.(ipfs)\.[^/?#]+(.*)$/;
var parseCid = (possibleIpfsString) => {
  if (!possibleIpfsString) {
    return null;
  }
  const ipfsProtocolCid = possibleIpfsString.match(ipfsProtocolPattern)?.[2];
  const ipfsProtocolUrlIndicators = possibleIpfsString.match(ipfsProtocolPattern)?.[3];
  if (isCid(ipfsProtocolCid)) {
    return formatReturnCid(ipfsProtocolCid, ipfsProtocolUrlIndicators);
  }
  const subdomainGatewayCid = possibleIpfsString.match(
    subdomainGatewayPattern2
  )?.[1];
  const subdomainGatewayUrlIndicators = possibleIpfsString.match(
    subdomainGatewayPattern2
  )?.[3];
  if (isCid(subdomainGatewayCid)) {
    return formatReturnCid(subdomainGatewayCid, subdomainGatewayUrlIndicators);
  }
  const pathGatewayCid = possibleIpfsString.match(pathGatewayPattern2)?.[2];
  const pathGatewayUrlIndicators = possibleIpfsString.match(pathGatewayPattern2)?.[3];
  if (isCid(pathGatewayCid)) {
    return formatReturnCid(pathGatewayCid, pathGatewayUrlIndicators);
  }
  const ipfsCid = possibleIpfsString.match(ipfsCidPattern)?.[1];
  if (isCid(ipfsCid)) {
    return formatReturnCid(ipfsCid);
  }
  return null;
};
var isCid = (hash) => {
  try {
    if (!hash) {
      return false;
    }
    if (typeof hash === "string") {
      return Boolean(CID.parse(hash));
    }
    if (hash instanceof Uint8Array) {
      return Boolean(CID.decode(hash));
    }
    return Boolean(CID.asCID(hash));
  } catch {
    return false;
  }
};
var formatReturnCid = (cid, urlIndicators) => {
  const cidWithUrlIndicators = `${cid}${urlIndicators ?? ""}`;
  return {
    url: `ipfs://${cidWithUrlIndicators}`,
    id: cidWithUrlIndicators
  };
};

// src/utils/string.ts
var b64Encode = (input) => {
  try {
    if (typeof window !== "undefined" && "btoa" in window) {
      return window?.btoa?.(input) ?? null;
    }
    return Buffer?.from(input, "binary")?.toString("base64") ?? null;
  } catch (e) {
    return null;
  }
};
var b64Decode = (input) => {
  try {
    if (typeof window !== "undefined" && "atob" in window) {
      return window?.atob?.(input) ?? null;
    }
    return Buffer?.from(input, "base64")?.toString("binary") ?? null;
  } catch (e) {
    return null;
  }
};
var b64UrlEncode = (input) => {
  return escapeInput(b64Encode(input));
};
var b64UrlDecode = (input) => {
  const unescaped = unescapeInput(input);
  if (unescaped) {
    return b64Decode(unescaped);
  }
  return null;
};
var unescapeInput = (input) => {
  return input ? (input + "===".slice((input.length + 3) % 4)).replace(/-/g, "+").replace(/_/g, "/") : null;
};
var escapeInput = (input) => {
  return input?.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "") ?? null;
};

// src/utils/types.ts
var noop = (..._args) => {
};

// src/utils/warn.ts
var cache = /* @__PURE__ */ new Set();
function warn(message, id) {
  if (!cache.has(id ?? message)) {
    console.warn(message);
    cache.add(message);
  }
}
export {
  b64Decode,
  b64Encode,
  b64UrlDecode,
  b64UrlEncode,
  deepMerge,
  noop,
  omit,
  parseArweaveTxId,
  parseCid,
  pick,
  warn
};
//# sourceMappingURL=index.js.map