"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  b64Decode: () => b64Decode,
  b64Encode: () => b64Encode,
  b64UrlDecode: () => b64UrlDecode,
  b64UrlEncode: () => b64UrlEncode,
  deepMerge: () => deepMerge,
  noop: () => noop,
  omit: () => omit,
  parseArweaveTxId: () => parseArweaveTxId,
  parseCid: () => parseCid,
  pick: () => pick,
  warn: () => warn
});
module.exports = __toCommonJS(utils_exports);

// src/utils/deepMerge.ts
var isObject = (obj) => {
  if (typeof obj === "object" && obj !== null) {
    if (typeof Object.getPrototypeOf === "function") {
      const prototype = Object.getPrototypeOf(obj);
      return prototype === Object.prototype || prototype === null;
    }
    return Object.prototype.toString.call(obj) === "[object Object]";
  }
  return false;
};
var merge = (...objects) => objects.reduce((result, current) => {
  if (Array.isArray(current)) {
    throw new TypeError(
      "Arguments provided to ts-deepmerge must be objects, not arrays."
    );
  }
  Object.keys(current).forEach((key) => {
    if (["__proto__", "constructor", "prototype"].includes(key)) {
      return;
    }
    if (Array.isArray(result[key]) && Array.isArray(current[key])) {
      result[key] = merge.options.mergeArrays ? Array.from(new Set(result[key].concat(current[key]))) : current[key];
    } else if (isObject(result[key]) && isObject(current[key])) {
      result[key] = merge(result[key], current[key]);
    } else {
      result[key] = current[key];
    }
  });
  return result;
}, {});
var defaultOptions = {
  mergeArrays: true
};
merge.options = defaultOptions;
merge.withOptions = (options, ...objects) => {
  merge.options = {
    mergeArrays: true,
    ...options
  };
  const result = merge(...objects);
  merge.options = defaultOptions;
  return result;
};
var deepMerge = merge;

// src/utils/omick.ts
var pick = (obj, ...keys) => {
  try {
    const objectKeys = Object.keys(obj);
    return keys.filter((key) => objectKeys.includes(key)).reduce(
      (prev, curr) => ({
        // biome-ignore lint/performance/noAccumulatingSpread: <explanation>
        ...prev,
        [curr]: obj[curr]
      }),
      {}
    );
  } catch (e) {
    throw new Error("Could not pick keys for object.");
  }
};
function omit(obj, ...keys) {
  try {
    const objectKeys = Object.keys(obj);
    return objectKeys.filter((objectKey) => !keys.some((key) => String(key) === objectKey)).reduce(
      (prev, curr) => ({
        // biome-ignore lint/performance/noAccumulatingSpread: <explanation>
        ...prev,
        [curr]: obj[curr]
      }),
      {}
    );
  } catch (e) {
    throw new Error("Could not omit keys for object.");
  }
}

// src/utils/storage/arweave.ts
var arweaveProtocolPattern = /^(ar):\/\/([^/?#]+)(.*)$/;
var pathGatewayPattern = /^https:\/\/(arweave\.net|arweave\.dev)\/([^/?#]+)(.*)$/;
var subdomainGatewayPattern = /^https:\/\/([^/]+)\.(arweave\.net|arweave\.dev)\/([^/?#]+)(.*)$/;
var parseArweaveTxId = (possibleArweaveString) => {
  if (!possibleArweaveString) {
    return null;
  }
  const arweaveProtocolHash = possibleArweaveString.match(
    arweaveProtocolPattern
  )?.[2];
  const arweaveProtocolUrlIndicators = possibleArweaveString.match(
    arweaveProtocolPattern
  )?.[3];
  if (arweaveProtocolHash) {
    return formatReturnHash(arweaveProtocolHash, arweaveProtocolUrlIndicators);
  }
  const subdomainGatewayHash = possibleArweaveString.match(
    subdomainGatewayPattern
  )?.[3];
  const subdomainGatewayUrlIndicators = possibleArweaveString.match(
    subdomainGatewayPattern
  )?.[4];
  if (subdomainGatewayHash) {
    return formatReturnHash(
      subdomainGatewayHash,
      subdomainGatewayUrlIndicators
    );
  }
  const pathGatewayHash = possibleArweaveString.match(pathGatewayPattern)?.[2];
  const pathGatewayUrlIndicators = possibleArweaveString.match(pathGatewayPattern)?.[3];
  if (pathGatewayHash) {
    return formatReturnHash(pathGatewayHash, pathGatewayUrlIndicators);
  }
  return null;
};
var formatReturnHash = (hash, urlIndicators) => {
  const hashWithUrlIndicators = `${hash}${urlIndicators ?? ""}`;
  return {
    url: `ar://${hashWithUrlIndicators}`,
    id: hashWithUrlIndicators
  };
};

// src/utils/storage/ipfs.ts
var import_cid = require("multiformats/cid");
var ipfsCidPattern = /^([^/?#]+)$/;
var ipfsProtocolPattern = /^(ipfs):\/\/([^/?#]+)(.*)$/;
var pathGatewayPattern2 = /^https?:\/\/[^/]+\/(ipfs)\/([^/?#]+)(.*)$/;
var subdomainGatewayPattern2 = /^https?:\/\/([^/]+)\.(ipfs)\.[^/?#]+(.*)$/;
var parseCid = (possibleIpfsString) => {
  if (!possibleIpfsString) {
    return null;
  }
  const ipfsProtocolCid = possibleIpfsString.match(ipfsProtocolPattern)?.[2];
  const ipfsProtocolUrlIndicators = possibleIpfsString.match(ipfsProtocolPattern)?.[3];
  if (isCid(ipfsProtocolCid)) {
    return formatReturnCid(ipfsProtocolCid, ipfsProtocolUrlIndicators);
  }
  const subdomainGatewayCid = possibleIpfsString.match(
    subdomainGatewayPattern2
  )?.[1];
  const subdomainGatewayUrlIndicators = possibleIpfsString.match(
    subdomainGatewayPattern2
  )?.[3];
  if (isCid(subdomainGatewayCid)) {
    return formatReturnCid(subdomainGatewayCid, subdomainGatewayUrlIndicators);
  }
  const pathGatewayCid = possibleIpfsString.match(pathGatewayPattern2)?.[2];
  const pathGatewayUrlIndicators = possibleIpfsString.match(pathGatewayPattern2)?.[3];
  if (isCid(pathGatewayCid)) {
    return formatReturnCid(pathGatewayCid, pathGatewayUrlIndicators);
  }
  const ipfsCid = possibleIpfsString.match(ipfsCidPattern)?.[1];
  if (isCid(ipfsCid)) {
    return formatReturnCid(ipfsCid);
  }
  return null;
};
var isCid = (hash) => {
  try {
    if (!hash) {
      return false;
    }
    if (typeof hash === "string") {
      return Boolean(import_cid.CID.parse(hash));
    }
    if (hash instanceof Uint8Array) {
      return Boolean(import_cid.CID.decode(hash));
    }
    return Boolean(import_cid.CID.asCID(hash));
  } catch {
    return false;
  }
};
var formatReturnCid = (cid, urlIndicators) => {
  const cidWithUrlIndicators = `${cid}${urlIndicators ?? ""}`;
  return {
    url: `ipfs://${cidWithUrlIndicators}`,
    id: cidWithUrlIndicators
  };
};

// src/utils/string.ts
var b64Encode = (input) => {
  try {
    if (typeof window !== "undefined" && "btoa" in window) {
      return window?.btoa?.(input) ?? null;
    }
    return Buffer?.from(input, "binary")?.toString("base64") ?? null;
  } catch (e) {
    return null;
  }
};
var b64Decode = (input) => {
  try {
    if (typeof window !== "undefined" && "atob" in window) {
      return window?.atob?.(input) ?? null;
    }
    return Buffer?.from(input, "base64")?.toString("binary") ?? null;
  } catch (e) {
    return null;
  }
};
var b64UrlEncode = (input) => {
  return escapeInput(b64Encode(input));
};
var b64UrlDecode = (input) => {
  const unescaped = unescapeInput(input);
  if (unescaped) {
    return b64Decode(unescaped);
  }
  return null;
};
var unescapeInput = (input) => {
  return input ? (input + "===".slice((input.length + 3) % 4)).replace(/-/g, "+").replace(/_/g, "/") : null;
};
var escapeInput = (input) => {
  return input?.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "") ?? null;
};

// src/utils/types.ts
var noop = (..._args) => {
};

// src/utils/warn.ts
var cache = /* @__PURE__ */ new Set();
function warn(message, id) {
  if (!cache.has(id ?? message)) {
    console.warn(message);
    cache.add(message);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  b64Decode,
  b64Encode,
  b64UrlDecode,
  b64UrlEncode,
  deepMerge,
  noop,
  omit,
  parseArweaveTxId,
  parseCid,
  pick,
  warn
});
//# sourceMappingURL=index.cjs.map