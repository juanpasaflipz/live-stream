{"version":3,"sources":["../src/external.ts","../src/media/mime.ts","../src/media/src.ts","../src/media/external.ts"],"sourcesContent":["export type Address = `0x${string}`;\nexport type Hash = `0x${string}`;\n\nexport { getIngest, getSrc } from \"./media/external\";\nexport type {\n  CloudflareStreamData,\n  CloudflareUrlData,\n  LivepeerAttestation,\n  LivepeerAttestationIpfs,\n  LivepeerAttestationStorage,\n  LivepeerAttestations,\n  LivepeerDomain,\n  LivepeerMessage,\n  LivepeerMeta,\n  LivepeerName,\n  LivepeerPhase,\n  LivepeerPlaybackInfo,\n  LivepeerPlaybackInfoType,\n  LivepeerPlaybackPolicy,\n  LivepeerPrimaryType,\n  LivepeerSignatureType,\n  LivepeerSource,\n  LivepeerStorageStatus,\n  LivepeerStream,\n  LivepeerTasks,\n  LivepeerTypeT,\n  LivepeerVersion,\n} from \"./media/external\";\n","export type MimeType = keyof typeof mime;\nexport type MimeValue = (typeof mime)[MimeType][number];\n\nexport const getMimeType = (ending: string): MimeType | null => {\n  for (const value of Object.keys(mime) as MimeType[]) {\n    if (mime[value]?.some((v) => v === ending)) {\n      return value;\n    }\n  }\n\n  return null;\n};\n\nconst mime = {\n  \"application/mp4\": [\"mp4s\", \"m4p\"],\n  \"application/ogg\": [\"ogx\"],\n  \"application/vnd.apple.mpegurl\": [\"m3u8\"],\n  \"audio/3gpp\": [\"*3gpp\"],\n  \"audio/adpcm\": [\"adp\"],\n  \"audio/amr\": [\"amr\"],\n  \"audio/basic\": [\"au\", \"snd\"],\n  \"audio/midi\": [\"mid\", \"midi\", \"kar\", \"rmi\"],\n  \"audio/mobile-xmf\": [\"mxmf\"],\n  \"audio/mp3\": [\"*mp3\"],\n  \"audio/mp4\": [\"m4a\", \"mp4a\"],\n  \"audio/mpeg\": [\"mpga\", \"mp2\", \"mp2a\", \"mp3\", \"m2a\", \"m3a\"],\n  \"audio/ogg\": [\"oga\", \"ogg\", \"spx\", \"opus\"],\n  \"audio/s3m\": [\"s3m\"],\n  \"audio/silk\": [\"sil\"],\n  \"audio/vnd.dece.audio\": [\"uva\", \"uvva\"],\n  \"audio/vnd.digital-winds\": [\"eol\"],\n  \"audio/vnd.dra\": [\"dra\"],\n  \"audio/vnd.dts.hd\": [\"dtshd\"],\n  \"audio/vnd.dts\": [\"dts\"],\n  \"audio/vnd.lucent.voice\": [\"lvp\"],\n  \"audio/vnd.ms-playready.media.pya\": [\"pya\"],\n  \"audio/vnd.nuera.ecelp4800\": [\"ecelp4800\"],\n  \"audio/vnd.nuera.ecelp7470\": [\"ecelp7470\"],\n  \"audio/vnd.nuera.ecelp9600\": [\"ecelp9600\"],\n  \"audio/vnd.rip\": [\"rip\"],\n  \"audio/wav\": [\"wav\"],\n  \"audio/wave\": [\"*wav\"],\n  \"audio/webm\": [\"weba\"],\n  \"audio/x-aac\": [\"aac\"],\n  \"audio/x-aiff\": [\"aif\", \"aiff\", \"aifc\"],\n  \"audio/x-caf\": [\"caf\"],\n  \"audio/x-flac\": [\"flac\"],\n  \"audio/x-m4a\": [\"*m4a\"],\n  \"audio/x-matroska\": [\"mka\"],\n  \"audio/x-mpegurl\": [\"m3u\"],\n  \"audio/x-ms-wax\": [\"wax\"],\n  \"audio/x-ms-wma\": [\"wma\"],\n  \"audio/x-pn-realaudio-plugin\": [\"rmp\"],\n  \"audio/x-pn-realaudio\": [\"ram\", \"ra\"],\n  \"audio/x-realaudio\": [\"*ra\"],\n  \"audio/x-wav\": [\"*wav\"],\n  \"audio/xm\": [\"xm\"],\n  \"video/3gpp\": [\"3gp\", \"3gpp\"],\n  \"video/3gpp2\": [\"3g2\"],\n  \"video/h261\": [\"h261\"],\n  \"video/h263\": [\"h263\"],\n  \"video/h264\": [\"h264\"],\n  \"video/iso.segment\": [\"m4s\"],\n  \"video/jpeg\": [\"jpgv\"],\n  \"video/jpm\": [\"*jpm\", \"jpgm\"],\n  \"video/mj2\": [\"mj2\", \"mjp2\"],\n  \"video/mp2t\": [\"ts\"],\n  \"video/mp4\": [\"mp4\", \"mp4v\", \"mpg4\"],\n  \"video/mpeg\": [\"mpeg\", \"mpg\", \"mpe\", \"m1v\", \"m2v\"],\n  \"video/ogg\": [\"ogv\"],\n  \"video/quicktime\": [\"qt\", \"mov\"],\n  \"video/vnd.dece.hd\": [\"uvh\", \"uvvh\"],\n  \"video/vnd.dece.mobile\": [\"uvm\", \"uvvm\"],\n  \"video/vnd.dece.pd\": [\"uvp\", \"uvvp\"],\n  \"video/vnd.dece.sd\": [\"uvs\", \"uvvs\"],\n  \"video/vnd.dece.video\": [\"uvv\", \"uvvv\"],\n  \"video/vnd.dvb.file\": [\"dvb\"],\n  \"video/vnd.fvt\": [\"fvt\"],\n  \"video/vnd.mpegurl\": [\"mxu\", \"m4u\"],\n  \"video/vnd.ms-playready.media.pyv\": [\"pyv\"],\n  \"video/vnd.uvvu.mp4\": [\"uvu\", \"uvvu\"],\n  \"video/vnd.vivo\": [\"viv\"],\n  \"video/vp8\": [\"vp8\"],\n  \"video/webm\": [\"webm\"],\n  \"video/x-f4v\": [\"f4v\"],\n  \"video/x-fli\": [\"fli\"],\n  \"video/x-flv\": [\"flv\"],\n  \"video/x-m4v\": [\"m4v\"],\n  \"video/x-matroska\": [\"mkv\", \"mk3d\", \"mks\"],\n  \"video/x-mng\": [\"mng\"],\n  \"video/x-ms-asf\": [\"asf\", \"asx\"],\n  \"video/x-ms-vob\": [\"vob\"],\n  \"video/x-ms-wm\": [\"wm\"],\n  \"video/x-ms-wmv\": [\"wmv\"],\n  \"video/x-ms-wmx\": [\"wmx\"],\n  \"video/x-ms-wvx\": [\"wvx\"],\n  \"video/x-msvideo\": [\"avi\"],\n  \"video/x-sgi-movie\": [\"movie\"],\n  \"video/x-smv\": [\"smv\"],\n} as const;\n","import type { ElementSize } from \"./controller\";\nimport { type MimeType, getMimeType } from \"./mime\";\n\ntype AudioExtension =\n  | \"m4a\"\n  | \"mp4a\"\n  | \"mpga\"\n  | \"mp2\"\n  | \"mp2a\"\n  | \"mp3\"\n  | \"m2a\"\n  | \"m3a\"\n  | \"wav\"\n  | \"weba\"\n  | \"aac\"\n  | \"oga\"\n  | \"spx\";\ntype VideoExtension = \"mp4\" | \"ogv\" | \"webm\" | \"mov\" | \"m4v\" | \"avi\" | \"m3u8\";\ntype HlsExtension = \"m3u8\";\ntype VideoTextTrackExtension = \"vtt\";\n\ntype OptionalQueryParams = `?${string}` | \"\";\n\ntype BaseSrc = {\n  type: \"audio\" | \"video\" | \"hls\" | \"webrtc\" | \"image\" | \"vtt\";\n  src: string;\n  mime: MimeType | null;\n  width: number | null;\n  height: number | null;\n};\nexport interface AudioSrc extends BaseSrc {\n  type: \"audio\";\n  src: `${string}${AudioExtension}${OptionalQueryParams}`;\n}\nexport interface VideoSrc extends BaseSrc {\n  type: \"video\";\n  src: `${string}${VideoExtension}${OptionalQueryParams}`;\n}\nexport interface ImageSrc extends BaseSrc {\n  type: \"image\";\n  src: `${string}${OptionalQueryParams}`;\n}\nexport interface VideoTextTrackSrc extends BaseSrc {\n  type: \"vtt\";\n  src: `${string}${VideoTextTrackExtension}${OptionalQueryParams}`;\n}\n\nexport interface Base64Src extends BaseSrc {\n  type: \"video\";\n  src: `${string}`;\n}\nexport interface HlsSrc extends BaseSrc {\n  type: \"hls\";\n  src: `${string}${HlsExtension}${OptionalQueryParams}`;\n}\nexport interface WebRTCSrc extends BaseSrc {\n  type: \"webrtc\";\n  src: `${string}${OptionalQueryParams}`;\n}\nexport interface FlvSrc extends BaseSrc {\n  type: \"video\";\n  src: `${string}`;\n}\nexport type Src =\n  | AudioSrc\n  | HlsSrc\n  | FlvSrc\n  | VideoSrc\n  | Base64Src\n  | WebRTCSrc\n  | ImageSrc\n  | VideoTextTrackSrc;\n\nexport type AccessControlParams = {\n  jwt?: string | null;\n  accessKey?: string | null;\n};\n\nexport type VideoQuality =\n  | \"1080p\"\n  | \"720p\"\n  | \"480p\"\n  | \"360p\"\n  | \"240p\"\n  | \"144p\"\n  | \"auto\";\n\n/**\n * Represents a single track selector\n */\nexport type SingleTrackSelector =\n  /** Selects no tracks */\n  | \"none\"\n  /** Selects all tracks */\n  | \"all\"\n  /** Selects all tracks */\n  | \"*\"\n  /** Specific track ID */\n  | `${number}`\n  /** Highest bit rate */\n  | \"maxbps\"\n  /** Lowest bit rate */\n  | \"minbps\"\n  /** Specific bit rate */\n  | `${number}bps`\n  /** Specific bit rate */\n  | `${number}kbps`\n  /** Specific bit rate */\n  | `${number}mbps`\n  /** Greater than specific bit rate */\n  | `>${number}bps`\n  /** Greater than specific bit rate */\n  | `>${number}kbps`\n  /** Greater than specific bit rate */\n  | `>${number}mbps`\n  /** Less than specific bit rate */\n  | `<${number}bps`\n  /** Less than specific bit rate */\n  | `<${number}kbps`\n  /** Less than specific bit rate */\n  | `<${number}mbps`\n  /** Max less than specific bit rate */\n  | `max<${number}bps`\n  /** Max less than specific bit rate */\n  | `max<${number}kbps`\n  /** Max less than specific bit rate */\n  | `max<${number}mbps`;\n\n/**\n * Represents a single audio track selector\n */\nexport type SingleAudioTrackSelector =\n  | SingleTrackSelector\n  /** Channel count */\n  | \"surround\"\n  /** Channel count */\n  | \"mono\"\n  /** Channel count */\n  | \"stereo\"\n  /** Channel count */\n  | `${number}ch`;\n\n/**\n * Represents a single video track selector\n */\nexport type SingleVideoTrackSelector =\n  | SingleTrackSelector\n  /** Highest pixel surface area */\n  | \"maxres\"\n  /** Lowest pixel surface area */\n  | \"minres\"\n  /** Specific pixel surface area */\n  | `${number}x${number}`\n  /** Closest to specific pixel surface area */\n  | `~${number}x${number}`\n  /** Greater than pixel surface area */\n  | `>${number}x${number}`\n  /** Less than pixel surface area */\n  | `<${number}x${number}`\n  /** Resolution */\n  | \"720p\"\n  /** Resolution */\n  | \"1080p\"\n  /** Resolution */\n  | \"1440p\"\n  /** Resolution */\n  | \"2k\"\n  /** Resolution */\n  | \"4k\"\n  /** Resolution */\n  | \"5k\"\n  /** Resolution */\n  | \"8k\";\n\n/**\n * Generic track selector for a given type\n */\ntype TrackSelector<T extends string> =\n  | T\n  /** Union of selectors */\n  | `${T},${T}`\n  /** Difference of selectors */\n  | `${T},!${T}`\n  /** Intersection of selectors */\n  | `${T},|${T}`;\n\nexport type VideoTrackSelector = TrackSelector<SingleVideoTrackSelector>;\nexport type AudioTrackSelector = TrackSelector<SingleAudioTrackSelector>;\n\nconst audioExtensions =\n  /\\.(m4a|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\\?)/i;\nconst base64String = /data:video/i;\nconst hlsExtensions = /\\.(m3u8)($|\\?)/i;\nconst flvExtensions = /\\/(flv)\\//i;\nconst imageExtensions = /\\.(jpg|jpeg|png|gif|bmp|webp)($|\\?)/i;\nconst vttExtensions = /\\.(vtt)($|\\?)/i;\nconst mimeFromBase64Pattern = /data:(.+?);base64/;\nconst videoExtensions = /\\.(mp4|ogv|webm|mov|m4v|avi|m3u8)($|\\?)/i;\nconst webrtcExtensions = /(webrtc|sdp)/i;\n\nexport const getMediaSourceType = (\n  src: string | null,\n  opts?: {\n    sizing?: ElementSize;\n  },\n): Src | null => {\n  if (!src) {\n    return null;\n  }\n\n  const sourceTest = src?.toLowerCase();\n\n  const base64Mime = sourceTest.match(mimeFromBase64Pattern);\n  const resolvedWidth = opts?.sizing?.width ?? null;\n  const resolvedHeight = opts?.sizing?.height ?? null;\n\n  return webrtcExtensions.test(sourceTest)\n    ? {\n        type: \"webrtc\",\n        src: src as WebRTCSrc[\"src\"],\n        mime: \"video/h264\",\n        width: resolvedWidth,\n        height: resolvedHeight,\n      }\n    : hlsExtensions.test(sourceTest)\n      ? {\n          type: \"hls\",\n          src: src as HlsSrc[\"src\"],\n          mime: getMimeType(hlsExtensions.exec(sourceTest)?.[1] ?? \"\"),\n          width: resolvedWidth,\n          height: resolvedHeight,\n        }\n      : videoExtensions.test(sourceTest)\n        ? {\n            type: \"video\",\n            src: src as VideoSrc[\"src\"],\n            mime: getMimeType(videoExtensions.exec(sourceTest)?.[1] ?? \"\"),\n            width: resolvedWidth,\n            height: resolvedHeight,\n          }\n        : audioExtensions.test(sourceTest)\n          ? {\n              type: \"audio\",\n              src: src as AudioSrc[\"src\"],\n              mime: getMimeType(audioExtensions.exec(sourceTest)?.[1] ?? \"\"),\n              width: resolvedWidth,\n              height: resolvedHeight,\n            }\n          : base64String.test(sourceTest)\n            ? {\n                type: \"video\",\n                src: src as Base64Src[\"src\"],\n                mime: base64Mime ? (base64Mime[1] as MimeType) : \"video/mp4\",\n                width: resolvedWidth,\n                height: resolvedHeight,\n              }\n            : imageExtensions.test(sourceTest)\n              ? {\n                  type: \"image\",\n                  src: src as ImageSrc[\"src\"],\n                  mime: getMimeType(\n                    imageExtensions.exec(sourceTest)?.[1] ?? \"\",\n                  ),\n                  width: resolvedWidth,\n                  height: resolvedHeight,\n                }\n              : vttExtensions.test(sourceTest)\n                ? {\n                    type: \"vtt\",\n                    src: src as VideoTextTrackSrc[\"src\"],\n                    mime: getMimeType(\n                      vttExtensions.exec(sourceTest)?.[1] ?? \"\",\n                    ),\n                    width: null,\n                    height: null,\n                  }\n                : flvExtensions.test(sourceTest)\n                  ? {\n                      type: \"video\",\n                      src: src as FlvSrc[\"src\"],\n                      mime: \"video/x-flv\",\n                      width: resolvedWidth,\n                      height: resolvedHeight,\n                    }\n                  : null;\n};\n","import { type Src, getMediaSourceType } from \"./src\";\n\ntype InternalParsedSrc = {\n  url: string;\n  size?: number;\n  width?: number;\n  height?: number;\n  bitrate?: number;\n};\n\n/**\n * Parses various types of playback information and converts them into an array of Src objects.\n *\n * This function is designed to handle multiple input types: Livepeer playback info, Cloudflare stream data, Mux URLs, `string[]`, and `string`.\n * It processes these inputs to extract or construct source objects and then transforms these into `Src` inputs.\n *\n * These include the video playback information, as well as supporting data like thumbnails and VTT files, which can be used by the Player.\n *\n * The input types and their processing are as follows:\n * - `LivepeerPlaybackInfo`: Extracts the 'source' array from its 'meta' property.\n * - `LivepeerSource` or `LivepeerSource[]`: Uses the source object(s) directly.\n * - `CloudflareStreamData`: Retrieves the stream data and constructs Source objects.\n * - `CloudflareUrlData`: Uses the URL data to create a Source object.\n * - `string[]`: Assumes each string as a URL and creates an array of Source objects.\n * - `string`: Assumes the string is a URL and creates a single Source object.\n *\n * @param {LivepeerPlaybackInfo | LivepeerSource | LivepeerSource[] | CloudflareStreamData | CloudflareUrlData | string[] | string | null | undefined} source - The playback information to be parsed.\n * It can be of type `LivepeerPlaybackInfo`, `LivepeerSource`, `LivepeerSource[]`, `CloudflareStreamData`, `CloudflareUrlData`, `string[]` of URLs, or a single URL.\n * @returns {Src[] | null} An array of `Src` objects derived from the provided playback information, or null if the input is invalid or empty.\n *\n * Each `Src` object may contain the following properties:\n * - `url`: The URL of the media source.\n * - `size`: The size of the media file (optional).\n * - `width`: The width of the media (optional).\n * - `height`: The height of the media (optional).\n * - `bitrate`: The bitrate of the media (optional).\n */\nexport const getSrc = (\n  source:\n    | LivepeerPlaybackInfo\n    | LivepeerSource\n    | LivepeerSource[]\n    | CloudflareStreamData\n    | CloudflareUrlData\n    | string[]\n    | string\n    | null\n    | undefined,\n): Src[] | null => {\n  if (!source) {\n    return null;\n  }\n\n  let sources: InternalParsedSrc[] = [];\n\n  if (typeof source === \"string\") {\n    sources = [{ url: source }];\n  } else if (Array.isArray(source)) {\n    sources = source.map((s) =>\n      typeof s === \"string\"\n        ? { url: s }\n        : (s as LivepeerSource)?.url\n          ? { ...(s as InternalParsedSrc) }\n          : { url: s as unknown as string },\n    );\n  } else if (typeof source === \"object\") {\n    if (\"url\" in source && typeof source.url === \"string\") {\n      sources = [source as { url: string }];\n    } else if (\n      \"meta\" in source &&\n      typeof source.meta === \"object\" &&\n      source.meta &&\n      \"source\" in source.meta &&\n      Array.isArray(source.meta.source) &&\n      // biome-ignore lint/correctness/noUnsafeOptionalChaining: allow unsafe check\n      \"url\" in source?.meta?.source?.[0]\n    ) {\n      sources = source.meta.source as { url: string }[];\n    } else if (\n      \"webRTCPlayback\" in source &&\n      typeof source.webRTCPlayback === \"object\" &&\n      source.webRTCPlayback &&\n      \"url\" in source.webRTCPlayback &&\n      typeof source.webRTCPlayback.url === \"string\"\n    ) {\n      sources = [{ url: source.webRTCPlayback.url }];\n    }\n  }\n\n  // Process sources to get Src[]\n  const result = sources\n    .map((s) =>\n      getMediaSourceType(s.url, {\n        sizing:\n          s.height && s.width\n            ? {\n                width: s.width,\n                height: s.height,\n              }\n            : undefined,\n      }),\n    )\n    .filter((source) => source?.src)\n    // biome-ignore lint/style/noNonNullAssertion: filtered above\n    .map((source) => source!);\n\n  return result.length > 0 ? result : null;\n};\n\n/**\n * Parses various types of ingest information and converts them into a WHIP URL.\n *\n * This function is designed to handle multiple input types: strings (assumed to be stream keys or URLs), Cloudflare stream data, Cloudflare URL data, or Livepeer stream data. It processes these inputs to either return the URL directly, construct a WHIP URL using the provided base URL, or extract the URL from object data.\n *\n * - If the input is a valid URL (starting with http/https), it returns the URL directly.\n * - If the input is a string not starting with http/https, it treats the string as a stream key and constructs a WHIP URL using the provided base URL from opts.\n * - For object inputs (`CloudflareStreamData`, `CloudflareUrlData`, or `LivepeerStream`), it attempts to extract the URL from the `url`, `webRTC.url`, or `streamKey` properties.\n *\n * @param {string | LivepeerStream | CloudflareStreamData | CloudflareUrlData | null | undefined} ingest - The ingest information to be parsed. It can be a stream key, URL, Cloudflare stream data, Cloudflare URL data, or Livepeer stream data.\n * @param {Object} [opts] - Optional parameters.\n * @param {string | null | undefined} [opts.baseUrl] - The base URL used to construct a WHIP URL when a stream key is provided. Defaults to \"https://playback.livepeer.studio/webrtc\".\n * @returns {string | null} A WHIP URL derived from the provided ingest information, or null if the input is invalid, empty, or the necessary information to construct a WHIP URL is not provided.\n */\nexport const getIngest = (\n  ingest:\n    | string\n    | LivepeerStream\n    | CloudflareStreamData\n    | CloudflareUrlData\n    | null\n    | undefined,\n  opts: { baseUrl?: string | null | undefined } = {\n    baseUrl: \"https://playback.livepeer.studio/webrtc\",\n  },\n): string | null => {\n  if (!ingest) {\n    return null;\n  }\n\n  if (typeof ingest === \"string\" && ingest) {\n    if (/^https?:\\/\\//i.test(ingest)) {\n      return ingest;\n    }\n\n    // we assume a stream key has been passed here\n    if (opts.baseUrl) {\n      return `${opts.baseUrl}/${ingest}`;\n    }\n\n    return null;\n  }\n\n  if (typeof ingest === \"object\") {\n    if (\"url\" in ingest && typeof ingest.url === \"string\" && ingest.url) {\n      return ingest.url;\n    }\n\n    if (\n      \"streamKey\" in ingest &&\n      typeof ingest.streamKey === \"string\" &&\n      ingest.streamKey\n    ) {\n      if (opts.baseUrl) {\n        return `${opts.baseUrl}/${ingest.streamKey}`;\n      }\n    }\n\n    if (\n      \"webRTC\" in ingest &&\n      typeof ingest.webRTC === \"object\" &&\n      ingest.webRTC &&\n      \"url\" in ingest.webRTC &&\n      typeof ingest.webRTC.url === \"string\" &&\n      typeof ingest.webRTC.url\n    ) {\n      return ingest.webRTC.url;\n    }\n\n    return null;\n  }\n\n  return null;\n};\n\n/**\n * Phase of the asset storage\n */\nexport enum LivepeerPhase {\n  Waiting = \"waiting\",\n  Processing = \"processing\",\n  Ready = \"ready\",\n  Failed = \"failed\",\n  Reverted = \"reverted\",\n}\nexport interface LivepeerTasks {\n  /**\n   * ID of any currently running task that is exporting this\n   *\n   * @remarks\n   * asset to IPFS.\n   *\n   */\n  pending?: string;\n  /**\n   * ID of the last task to run successfully, that created\n   *\n   * @remarks\n   * the currently saved data.\n   *\n   */\n  last?: string;\n  /**\n   * ID of the last task to fail execution.\n   */\n  failed?: string;\n}\nexport interface LivepeerStorageStatus {\n  /**\n   * Phase of the asset storage\n   */\n  phase?: LivepeerPhase;\n  /**\n   * Current progress of the task updating the storage.\n   */\n  progress?: number;\n  /**\n   * Error message if the last storage changed failed.\n   */\n  errorMessage?: string;\n  tasks?: LivepeerTasks;\n}\n\n/**\n * Video Metadata EIP-712 primaryType\n */\nexport enum LivepeerPrimaryType {\n  VideoAttestation = \"VideoAttestation\",\n}\nexport enum LivepeerName {\n  VerifiableVideo = \"Verifiable Video\",\n}\nexport enum LivepeerVersion {\n  One = \"1\",\n}\n/**\n * Video Metadata EIP-712 domain\n */\nexport interface LivepeerDomain {\n  name?: LivepeerName;\n  version?: LivepeerVersion;\n}\nexport interface LivepeerAttestations {\n  role?: string;\n  address?: string;\n}\n/**\n * Video Metadata EIP-712 message content\n */\nexport interface LivepeerMessage {\n  video?: string;\n  attestations?: LivepeerAttestations[];\n  signer?: string;\n  timestamp?: number;\n}\nexport enum LivepeerSignatureType {\n  Eip712 = \"eip712\",\n  Flow = \"flow\",\n}\nexport interface LivepeerAttestationIpfs {\n  /**\n   * CID of the file on IPFS\n   */\n  cid?: string;\n  /**\n   * URL with IPFS scheme for the file\n   */\n  url?: string;\n  /**\n   * URL to access file via HTTP through an IPFS gateway\n   */\n  gatewayUrl?: string;\n  /**\n   * Timestamp (in milliseconds) at which IPFS export task was updated\n   *\n   * @remarks\n   *\n   */\n  updatedAt?: number;\n}\nexport interface LivepeerAttestationStorage {\n  ipfs?: LivepeerAttestationIpfs;\n  status?: LivepeerStorageStatus;\n}\nexport interface LivepeerAttestation {\n  id?: string;\n  /**\n   * Video Metadata EIP-712 primaryType\n   */\n  primaryType?: LivepeerPrimaryType;\n  /**\n   * Video Metadata EIP-712 domain\n   */\n  domain?: LivepeerDomain;\n  /**\n   * Video Metadata EIP-712 message content\n   */\n  message?: LivepeerMessage;\n  /**\n   * Video Metadata EIP-712 message signature\n   */\n  signature?: string;\n  /**\n   * Timestamp (in milliseconds) at which the object was created\n   */\n  createdAt?: number;\n  signatureType?: LivepeerSignatureType;\n  storage?: LivepeerAttestationStorage;\n}\n\nexport enum LivepeerTypeT {\n  Public = \"public\",\n  Jwt = \"jwt\",\n  Webhook = \"webhook\",\n}\n/**\n * Whether the playback policy for a asset or stream is public or signed\n */\nexport interface LivepeerPlaybackPolicy {\n  type?: LivepeerTypeT;\n  /**\n   * ID of the webhook to use for playback policy\n   */\n  webhookId?: string;\n  /**\n   * User-defined webhook context\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: any allowed\n  webhookContext?: Record<string, any>;\n}\n\nexport enum LivepeerPlaybackInfoType {\n  Live = \"live\",\n  Vod = \"vod\",\n  Recording = \"recording\",\n}\nexport interface LivepeerSource {\n  hrn?: string;\n  type?: string;\n  url?: string;\n  size?: number;\n  width?: number;\n  height?: number;\n  bitrate?: number;\n}\nexport interface LivepeerMeta {\n  live?: number;\n  /**\n   * Whether the playback policy for a asset or stream is public or signed\n   */\n  playbackPolicy?: LivepeerPlaybackPolicy;\n  source?: LivepeerSource[];\n  attestation?: LivepeerAttestation;\n}\nexport interface LivepeerPlaybackInfo {\n  type?: LivepeerPlaybackInfoType;\n  meta?: LivepeerMeta;\n}\n\nexport interface LivepeerStream {\n  streamKey?: string;\n}\n\nexport type CloudflareStreamData = {\n  webRTC?: CloudflareUrlData;\n  webRTCPlayback?: CloudflareUrlData;\n};\n\nexport type CloudflareUrlData = {\n  url?: string;\n};\n"],"mappings":"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","names":["source"]}