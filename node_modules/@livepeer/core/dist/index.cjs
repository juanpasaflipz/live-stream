"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/external.ts
var external_exports = {};
__export(external_exports, {
  getIngest: () => getIngest,
  getSrc: () => getSrc
});
module.exports = __toCommonJS(external_exports);

// src/media/mime.ts
var getMimeType = (ending) => {
  for (const value of Object.keys(mime)) {
    if (mime[value]?.some((v) => v === ending)) {
      return value;
    }
  }
  return null;
};
var mime = {
  "application/mp4": ["mp4s", "m4p"],
  "application/ogg": ["ogx"],
  "application/vnd.apple.mpegurl": ["m3u8"],
  "audio/3gpp": ["*3gpp"],
  "audio/adpcm": ["adp"],
  "audio/amr": ["amr"],
  "audio/basic": ["au", "snd"],
  "audio/midi": ["mid", "midi", "kar", "rmi"],
  "audio/mobile-xmf": ["mxmf"],
  "audio/mp3": ["*mp3"],
  "audio/mp4": ["m4a", "mp4a"],
  "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
  "audio/ogg": ["oga", "ogg", "spx", "opus"],
  "audio/s3m": ["s3m"],
  "audio/silk": ["sil"],
  "audio/vnd.dece.audio": ["uva", "uvva"],
  "audio/vnd.digital-winds": ["eol"],
  "audio/vnd.dra": ["dra"],
  "audio/vnd.dts.hd": ["dtshd"],
  "audio/vnd.dts": ["dts"],
  "audio/vnd.lucent.voice": ["lvp"],
  "audio/vnd.ms-playready.media.pya": ["pya"],
  "audio/vnd.nuera.ecelp4800": ["ecelp4800"],
  "audio/vnd.nuera.ecelp7470": ["ecelp7470"],
  "audio/vnd.nuera.ecelp9600": ["ecelp9600"],
  "audio/vnd.rip": ["rip"],
  "audio/wav": ["wav"],
  "audio/wave": ["*wav"],
  "audio/webm": ["weba"],
  "audio/x-aac": ["aac"],
  "audio/x-aiff": ["aif", "aiff", "aifc"],
  "audio/x-caf": ["caf"],
  "audio/x-flac": ["flac"],
  "audio/x-m4a": ["*m4a"],
  "audio/x-matroska": ["mka"],
  "audio/x-mpegurl": ["m3u"],
  "audio/x-ms-wax": ["wax"],
  "audio/x-ms-wma": ["wma"],
  "audio/x-pn-realaudio-plugin": ["rmp"],
  "audio/x-pn-realaudio": ["ram", "ra"],
  "audio/x-realaudio": ["*ra"],
  "audio/x-wav": ["*wav"],
  "audio/xm": ["xm"],
  "video/3gpp": ["3gp", "3gpp"],
  "video/3gpp2": ["3g2"],
  "video/h261": ["h261"],
  "video/h263": ["h263"],
  "video/h264": ["h264"],
  "video/iso.segment": ["m4s"],
  "video/jpeg": ["jpgv"],
  "video/jpm": ["*jpm", "jpgm"],
  "video/mj2": ["mj2", "mjp2"],
  "video/mp2t": ["ts"],
  "video/mp4": ["mp4", "mp4v", "mpg4"],
  "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
  "video/ogg": ["ogv"],
  "video/quicktime": ["qt", "mov"],
  "video/vnd.dece.hd": ["uvh", "uvvh"],
  "video/vnd.dece.mobile": ["uvm", "uvvm"],
  "video/vnd.dece.pd": ["uvp", "uvvp"],
  "video/vnd.dece.sd": ["uvs", "uvvs"],
  "video/vnd.dece.video": ["uvv", "uvvv"],
  "video/vnd.dvb.file": ["dvb"],
  "video/vnd.fvt": ["fvt"],
  "video/vnd.mpegurl": ["mxu", "m4u"],
  "video/vnd.ms-playready.media.pyv": ["pyv"],
  "video/vnd.uvvu.mp4": ["uvu", "uvvu"],
  "video/vnd.vivo": ["viv"],
  "video/vp8": ["vp8"],
  "video/webm": ["webm"],
  "video/x-f4v": ["f4v"],
  "video/x-fli": ["fli"],
  "video/x-flv": ["flv"],
  "video/x-m4v": ["m4v"],
  "video/x-matroska": ["mkv", "mk3d", "mks"],
  "video/x-mng": ["mng"],
  "video/x-ms-asf": ["asf", "asx"],
  "video/x-ms-vob": ["vob"],
  "video/x-ms-wm": ["wm"],
  "video/x-ms-wmv": ["wmv"],
  "video/x-ms-wmx": ["wmx"],
  "video/x-ms-wvx": ["wvx"],
  "video/x-msvideo": ["avi"],
  "video/x-sgi-movie": ["movie"],
  "video/x-smv": ["smv"]
};

// src/media/src.ts
var audioExtensions = /\.(m4a|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i;
var base64String = /data:video/i;
var hlsExtensions = /\.(m3u8)($|\?)/i;
var flvExtensions = /\/(flv)\//i;
var imageExtensions = /\.(jpg|jpeg|png|gif|bmp|webp)($|\?)/i;
var vttExtensions = /\.(vtt)($|\?)/i;
var mimeFromBase64Pattern = /data:(.+?);base64/;
var videoExtensions = /\.(mp4|ogv|webm|mov|m4v|avi|m3u8)($|\?)/i;
var webrtcExtensions = /(webrtc|sdp)/i;
var getMediaSourceType = (src, opts) => {
  if (!src) {
    return null;
  }
  const sourceTest = src?.toLowerCase();
  const base64Mime = sourceTest.match(mimeFromBase64Pattern);
  const resolvedWidth = opts?.sizing?.width ?? null;
  const resolvedHeight = opts?.sizing?.height ?? null;
  return webrtcExtensions.test(sourceTest) ? {
    type: "webrtc",
    src,
    mime: "video/h264",
    width: resolvedWidth,
    height: resolvedHeight
  } : hlsExtensions.test(sourceTest) ? {
    type: "hls",
    src,
    mime: getMimeType(hlsExtensions.exec(sourceTest)?.[1] ?? ""),
    width: resolvedWidth,
    height: resolvedHeight
  } : videoExtensions.test(sourceTest) ? {
    type: "video",
    src,
    mime: getMimeType(videoExtensions.exec(sourceTest)?.[1] ?? ""),
    width: resolvedWidth,
    height: resolvedHeight
  } : audioExtensions.test(sourceTest) ? {
    type: "audio",
    src,
    mime: getMimeType(audioExtensions.exec(sourceTest)?.[1] ?? ""),
    width: resolvedWidth,
    height: resolvedHeight
  } : base64String.test(sourceTest) ? {
    type: "video",
    src,
    mime: base64Mime ? base64Mime[1] : "video/mp4",
    width: resolvedWidth,
    height: resolvedHeight
  } : imageExtensions.test(sourceTest) ? {
    type: "image",
    src,
    mime: getMimeType(
      imageExtensions.exec(sourceTest)?.[1] ?? ""
    ),
    width: resolvedWidth,
    height: resolvedHeight
  } : vttExtensions.test(sourceTest) ? {
    type: "vtt",
    src,
    mime: getMimeType(
      vttExtensions.exec(sourceTest)?.[1] ?? ""
    ),
    width: null,
    height: null
  } : flvExtensions.test(sourceTest) ? {
    type: "video",
    src,
    mime: "video/x-flv",
    width: resolvedWidth,
    height: resolvedHeight
  } : null;
};

// src/media/external.ts
var getSrc = (source) => {
  if (!source) {
    return null;
  }
  let sources = [];
  if (typeof source === "string") {
    sources = [{ url: source }];
  } else if (Array.isArray(source)) {
    sources = source.map(
      (s) => typeof s === "string" ? { url: s } : s?.url ? { ...s } : { url: s }
    );
  } else if (typeof source === "object") {
    if ("url" in source && typeof source.url === "string") {
      sources = [source];
    } else if ("meta" in source && typeof source.meta === "object" && source.meta && "source" in source.meta && Array.isArray(source.meta.source) && // biome-ignore lint/correctness/noUnsafeOptionalChaining: allow unsafe check
    "url" in source?.meta?.source?.[0]) {
      sources = source.meta.source;
    } else if ("webRTCPlayback" in source && typeof source.webRTCPlayback === "object" && source.webRTCPlayback && "url" in source.webRTCPlayback && typeof source.webRTCPlayback.url === "string") {
      sources = [{ url: source.webRTCPlayback.url }];
    }
  }
  const result = sources.map(
    (s) => getMediaSourceType(s.url, {
      sizing: s.height && s.width ? {
        width: s.width,
        height: s.height
      } : void 0
    })
  ).filter((source2) => source2?.src).map((source2) => source2);
  return result.length > 0 ? result : null;
};
var getIngest = (ingest, opts = {
  baseUrl: "https://playback.livepeer.studio/webrtc"
}) => {
  if (!ingest) {
    return null;
  }
  if (typeof ingest === "string" && ingest) {
    if (/^https?:\/\//i.test(ingest)) {
      return ingest;
    }
    if (opts.baseUrl) {
      return `${opts.baseUrl}/${ingest}`;
    }
    return null;
  }
  if (typeof ingest === "object") {
    if ("url" in ingest && typeof ingest.url === "string" && ingest.url) {
      return ingest.url;
    }
    if ("streamKey" in ingest && typeof ingest.streamKey === "string" && ingest.streamKey) {
      if (opts.baseUrl) {
        return `${opts.baseUrl}/${ingest.streamKey}`;
      }
    }
    if ("webRTC" in ingest && typeof ingest.webRTC === "object" && ingest.webRTC && "url" in ingest.webRTC && typeof ingest.webRTC.url === "string" && typeof ingest.webRTC.url) {
      return ingest.webRTC.url;
    }
    return null;
  }
  return null;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getIngest,
  getSrc
});
//# sourceMappingURL=index.cjs.map