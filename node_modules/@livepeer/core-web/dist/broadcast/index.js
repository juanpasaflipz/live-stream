// src/broadcast.ts
import {
  createJSONStorage,
  persist,
  subscribeWithSelector
} from "zustand/middleware";
import { createStore } from "zustand/vanilla";
import { PERMISSIONS_ERROR_MESSAGE } from "@livepeer/core/errors";
import { warn as warn3 } from "@livepeer/core/utils";

// src/media/controls/controller.ts
import {
  ACCESS_CONTROL_ERROR_MESSAGE,
  BFRAMES_ERROR_MESSAGE,
  STREAM_OFFLINE_ERROR_MESSAGE
} from "@livepeer/core/errors";
import { warn } from "@livepeer/core/utils";

// src/hls/hls.ts
import Hls from "hls.js";
import {
  calculateVideoQualityDimensions
} from "@livepeer/core/media";

// src/media/utils.ts
import { noop } from "@livepeer/core/utils";
var isClient = () => typeof window !== "undefined";

// src/webrtc/shared.ts
import { NOT_ACCEPTABLE_ERROR_MESSAGE } from "@livepeer/core/errors";
var getRTCPeerConnectionConstructor = () => {
  if (!isClient()) {
    return null;
  }
  return window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection || null;
};
function createPeerConnection(host) {
  const RTCPeerConnectionConstructor = getRTCPeerConnectionConstructor();
  if (RTCPeerConnectionConstructor) {
    const hostNoPort = host?.split(":")[0];
    const iceServers = host ? [
      {
        urls: `stun:${hostNoPort}`
      },
      {
        urls: `turn:${hostNoPort}`,
        username: "livepeer",
        credential: "livepeer"
      }
    ] : [];
    return new RTCPeerConnectionConstructor({ iceServers });
  }
  throw new Error("No RTCPeerConnection constructor found in this browser.");
}
var DEFAULT_TIMEOUT = 1e4;
async function negotiateConnectionWithClientOffer(peerConnection, endpoint, ofr, controller, accessControl, sdpTimeout) {
  if (peerConnection && endpoint && ofr) {
    const response = await postSDPOffer(
      endpoint,
      ofr.sdp,
      controller,
      accessControl,
      sdpTimeout
    );
    if (response.ok) {
      const answerSDP = await response.text();
      await peerConnection.setRemoteDescription(
        new RTCSessionDescription({ type: "answer", sdp: answerSDP })
      );
      const playheadUtc = response.headers.get("Playhead-Utc");
      return new Date(playheadUtc ?? /* @__PURE__ */ new Date());
    }
    if (response.status === 406) {
      throw new Error(NOT_ACCEPTABLE_ERROR_MESSAGE);
    }
    const errorMessage = await response.text();
    throw new Error(errorMessage);
  }
  throw new Error("Peer connection not defined.");
}
async function constructClientOffer(peerConnection, endpoint) {
  if (peerConnection && endpoint) {
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    const ofr = await waitToCompleteICEGathering(peerConnection);
    if (!ofr) {
      throw Error("failed to gather ICE candidates for offer");
    }
    return ofr;
  }
  return null;
}
var playbackIdPattern = /([/+])([^/+?]+)$/;
var REPLACE_PLACEHOLDER = "PLAYBACK_ID";
var cachedRedirectUrl = null;
async function postSDPOffer(endpoint, data, controller, accessControl, sdpTimeout) {
  const id = setTimeout(
    () => controller.abort(),
    sdpTimeout ?? DEFAULT_TIMEOUT
  );
  const url = new URL(endpoint);
  const parsedMatches = url.pathname.match(playbackIdPattern);
  if (cachedRedirectUrl && parsedMatches?.[2]) {
    const clonedCachedUrl = new URL(cachedRedirectUrl);
    url.host = clonedCachedUrl.host;
    url.pathname = clonedCachedUrl.pathname.replace(
      REPLACE_PLACEHOLDER,
      parsedMatches[2]
    );
  }
  const response = await fetch(url.toString(), {
    method: "POST",
    mode: "cors",
    headers: {
      "content-type": "application/sdp",
      ...accessControl?.accessKey ? {
        "Livepeer-Access-Key": accessControl.accessKey
      } : {},
      ...accessControl?.jwt ? {
        "Livepeer-Jwt": accessControl.jwt
      } : {}
    },
    body: data,
    signal: controller.signal
  });
  clearTimeout(id);
  return response;
}
async function getRedirectUrl(endpoint, abortController, timeout) {
  try {
    if (cachedRedirectUrl) {
      const inputUrl = new URL(endpoint);
      inputUrl.host = cachedRedirectUrl.host;
      return inputUrl;
    }
    const id = setTimeout(
      () => abortController.abort(),
      timeout ?? DEFAULT_TIMEOUT
    );
    const response = await fetch(endpoint, {
      method: "HEAD",
      signal: abortController.signal
    });
    clearTimeout(id);
    const parsedUrl = new URL(response.url);
    if (parsedUrl) {
      const cachedUrl = new URL(parsedUrl);
      cachedUrl.pathname = cachedUrl.pathname.replace(
        playbackIdPattern,
        `$1${REPLACE_PLACEHOLDER}`
      );
      cachedRedirectUrl = cachedUrl;
    }
    return parsedUrl;
  } catch (e) {
    return null;
  }
}
async function waitToCompleteICEGathering(peerConnection) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(peerConnection.localDescription);
    }, 5e3);
    peerConnection.onicegatheringstatechange = (_ev) => {
      if (peerConnection.iceGatheringState === "complete") {
        resolve(peerConnection.localDescription);
      }
    };
  });
}

// src/media/controls/pictureInPicture.ts
var isPictureInPictureSupported = (element) => {
  if (typeof document === "undefined") {
    return true;
  }
  const videoElement = element ?? document.createElement("video");
  const isPiPDisabled = Boolean(
    videoElement.disablePictureInPicture
  );
  const { apiType } = getPictureInPictureMode(videoElement);
  return Boolean(apiType) && !isPiPDisabled;
};
var getPictureInPictureMode = (element) => {
  if (isClient() && element instanceof HTMLVideoElement) {
    if (document?.pictureInPictureEnabled) {
      return { apiType: "w3c", element };
    }
    if (element?.webkitSupportsPresentationMode?.("picture-in-picture")) {
      return { apiType: "webkit", element };
    }
  }
  return { apiType: null };
};

// src/webrtc/whip.ts
import { warn as warn2 } from "@livepeer/core/utils";
var VIDEO_WEBRTC_INITIALIZED_ATTRIBUTE = "data-livepeer-video-whip-initialized";
var createNewWHIP = ({
  ingestUrl,
  element,
  callbacks,
  sdpTimeout
}) => {
  if (element.getAttribute(VIDEO_WEBRTC_INITIALIZED_ATTRIBUTE) === "true") {
    return {
      destroy: () => {
      }
    };
  }
  element.setAttribute(VIDEO_WEBRTC_INITIALIZED_ATTRIBUTE, "true");
  let destroyed = false;
  const abortController = new AbortController();
  let peerConnection = null;
  getRedirectUrl(ingestUrl, abortController, sdpTimeout).then((redirectUrl) => {
    if (destroyed || !redirectUrl) {
      return;
    }
    const redirectUrlString = redirectUrl.toString().replace("video+", "");
    peerConnection = createPeerConnection(redirectUrl.host);
    if (peerConnection) {
      peerConnection.addEventListener("negotiationneeded", async (_ev) => {
        try {
          const ofr = await constructClientOffer(
            peerConnection,
            redirectUrlString
          );
          await negotiateConnectionWithClientOffer(
            peerConnection,
            ingestUrl,
            ofr,
            abortController,
            {},
            sdpTimeout
          );
        } catch (e) {
          callbacks?.onError?.(e);
        }
      });
      peerConnection.addEventListener(
        "connectionstatechange",
        async (_ev) => {
          try {
            if (peerConnection?.connectionState === "failed") {
              callbacks?.onError?.(new Error("Failed to connect to peer."));
            }
            if (peerConnection?.connectionState === "connected") {
              callbacks?.onConnected?.();
            }
          } catch (e) {
            callbacks?.onError?.(e);
          }
        }
      );
      callbacks?.onRTCPeerConnection?.(peerConnection);
    } else {
      warn2("Could not create peer connection.");
    }
  }).catch((e) => callbacks?.onError?.(e));
  return {
    destroy: () => {
      destroyed = true;
      abortController?.abort?.();
      peerConnection?.close?.();
      element?.removeAttribute?.(VIDEO_WEBRTC_INITIALIZED_ATTRIBUTE);
    }
  };
};
var attachMediaStreamToPeerConnection = async ({
  mediaStream,
  peerConnection
}) => {
  const newVideoTrack = mediaStream?.getVideoTracks?.()?.[0] ?? null;
  const newAudioTrack = mediaStream?.getAudioTracks?.()?.[0] ?? null;
  const transceivers = peerConnection.getTransceivers();
  let videoTransceiver = transceivers.find(
    (t) => t.receiver.track.kind === "video"
  );
  let audioTransceiver = transceivers.find(
    (t) => t.receiver.track.kind === "audio"
  );
  if (newVideoTrack) {
    if (videoTransceiver) {
      await videoTransceiver.sender.replaceTrack(newVideoTrack);
    } else {
      videoTransceiver = await peerConnection.addTransceiver(newVideoTrack, {
        direction: "sendonly"
      });
    }
  }
  if (newAudioTrack) {
    if (audioTransceiver) {
      await audioTransceiver.sender.replaceTrack(newAudioTrack);
    } else {
      audioTransceiver = await peerConnection.addTransceiver(newAudioTrack, {
        direction: "sendonly"
      });
    }
  }
};
var setMediaStreamTracksStatus = async ({
  enableVideo,
  enableAudio,
  mediaStream
}) => {
  for (const videoTrack of mediaStream.getVideoTracks()) {
    videoTrack.enabled = enableVideo;
  }
  for (const audioTrack of mediaStream.getAudioTracks()) {
    audioTrack.enabled = enableAudio;
  }
};
var getUserMedia = (constraints) => {
  if (typeof navigator === "undefined") {
    return null;
  }
  if (navigator?.mediaDevices?.getUserMedia) {
    return navigator.mediaDevices.getUserMedia(constraints);
  }
  if (navigator?.getUserMedia) {
    return navigator.getUserMedia(constraints);
  }
  if (navigator?.webkitGetUserMedia) {
    return navigator.webkitGetUserMedia(constraints);
  }
  if (navigator?.mozGetUserMedia) {
    return navigator.mozGetUserMedia(constraints);
  }
  if (navigator?.msGetUserMedia) {
    return navigator.msGetUserMedia(constraints);
  }
  warn2(
    "getUserMedia is not supported in this environment. Check if you are in a secure (HTTPS) context - https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia"
  );
  return null;
};
var getMediaDevices = () => {
  if (typeof navigator === "undefined") {
    return null;
  }
  if (!navigator.mediaDevices) {
    warn2(
      "mediaDevices was not found in this environment. Check if you are in a secure (HTTPS) context - https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia"
    );
    return null;
  }
  return navigator.mediaDevices;
};
var getDisplayMediaExists = () => {
  if (typeof navigator === "undefined") {
    return false;
  }
  if (!navigator?.mediaDevices?.getDisplayMedia) {
    return false;
  }
  return true;
};
var getDisplayMedia = (options) => {
  if (typeof navigator === "undefined") {
    warn2("getDisplayMedia does not exist in this environment.");
    return null;
  }
  if (!navigator?.mediaDevices?.getDisplayMedia) {
    warn2("getDisplayMedia does not exist in this environment.");
    return null;
  }
  return navigator.mediaDevices.getDisplayMedia(options);
};

// src/broadcast.ts
var delay = (ms) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};
var getBroadcastDeviceInfo = (version) => ({
  version,
  isMediaDevicesSupported: Boolean(getMediaDevices()),
  isRTCPeerConnectionSupported: Boolean(getRTCPeerConnectionConstructor()),
  isDisplayMediaSupported: Boolean(getDisplayMediaExists())
});
var createBroadcastStore = ({
  ingestUrl,
  device,
  storage,
  initialProps
}) => {
  const initialControls = {
    requestedUpdateDeviceListLastTime: 0,
    requestedForceRenegotiateLastTime: 0,
    requestedAudioInputDeviceId: "default",
    requestedVideoInputDeviceId: null,
    previousVideoInputDeviceId: null,
    mediaDevices: null
  };
  const store = createStore(
    subscribeWithSelector(
      persist(
        (set, get) => ({
          audio: initialProps?.audio !== false,
          video: initialProps?.video !== false,
          hydrated: false,
          mounted: false,
          enabled: initialProps?.forceEnabled ?? false,
          status: "idle",
          mediaStream: null,
          mediaDevices: null,
          peerConnection: null,
          ingestUrl: ingestUrl ?? null,
          mediaDeviceIds: {
            audioinput: "default",
            videoinput: "default"
          },
          aria: {
            audioTrigger: initialProps?.audio === false ? "Turn audio on (space)" : "Turn audio off (space)",
            start: "Start broadcasting (b)",
            screenshareTrigger: "Share screen (d)",
            videoTrigger: initialProps?.video === false ? "Turn video on (v)" : "Turn video off (v)"
          },
          __initialProps: {
            aspectRatio: initialProps?.aspectRatio ?? null,
            audio: initialProps?.audio ?? true,
            creatorId: initialProps.creatorId ?? null,
            forceEnabled: initialProps?.forceEnabled ?? false,
            hotkeys: initialProps.hotkeys ?? true,
            ingestUrl: ingestUrl ?? null,
            video: initialProps?.video ?? true
          },
          __device: device,
          __controls: initialControls,
          __metadata: null,
          __controlsFunctions: {
            updateMediaStream: (mediaStream) => set(() => ({
              mediaStream
            })),
            setPeerConnection: (peerConnection) => set(() => ({
              peerConnection
            })),
            setIngestUrl: (ingestUrl2) => set(() => ({
              ingestUrl: ingestUrl2
            })),
            requestForceRenegotiate: () => set(({ __controls }) => ({
              __controls: {
                ...__controls,
                requestedForceRenegotiateLastTime: Date.now()
              }
            })),
            rotateAudioSource: () => set(({ mediaDeviceIds, mediaDevices, __controls }) => {
              if (!mediaDevices) {
                warn3(
                  "Could not rotate audio source, no audio media devices detected."
                );
                return {};
              }
              const audioDevices = mediaDevices.filter(
                (m) => m.kind === "audioinput"
              );
              const currentAudioInputIndex = audioDevices.findIndex(
                (s) => s.deviceId === mediaDeviceIds.audioinput
              );
              const nextAudioInputDevice = audioDevices[(currentAudioInputIndex + 1) % audioDevices.length] ?? null;
              return {
                __controls: {
                  ...__controls,
                  requestedAudioInputDeviceId: nextAudioInputDevice.deviceId
                }
              };
            }),
            rotateVideoSource: () => set(({ mediaDeviceIds, mediaDevices, __controls }) => {
              if (!mediaDevices) {
                warn3(
                  "Could not rotate video source, no video media devices detected."
                );
                return {};
              }
              const videoDevices = mediaDevices.filter(
                (m) => m.kind === "videoinput"
              );
              const currentVideoInputIndex = videoDevices.findIndex(
                (s) => s.deviceId === mediaDeviceIds.videoinput
              );
              const nextVideoInputDevice = videoDevices[(currentVideoInputIndex + 1) % videoDevices.length] ?? null;
              return {
                __controls: {
                  ...__controls,
                  requestedVideoInputDeviceId: nextVideoInputDevice.deviceId
                }
              };
            }),
            toggleDisplayMedia: () => set(({ __controls, mediaDeviceIds, aria }) => {
              if (mediaDeviceIds.videoinput === "screen") {
                return {
                  aria: {
                    ...aria,
                    screenshareTrigger: "Share screen (d)"
                  },
                  __controls: {
                    ...__controls,
                    requestedVideoInputDeviceId: __controls.previousVideoInputDeviceId
                  }
                };
              }
              return {
                aria: {
                  ...aria,
                  screenshareTrigger: "Stop sharing screen (d)"
                },
                __controls: {
                  ...__controls,
                  previousVideoInputDeviceId: mediaDeviceIds.videoinput,
                  requestedVideoInputDeviceId: "screen"
                }
              };
            }),
            setInitialState: (deviceIds, audio, video) => set(({ __controls }) => ({
              hydrated: true,
              audio,
              video,
              __controls: {
                ...__controls,
                requestedAudioInputDeviceId: deviceIds?.audioinput ?? "default",
                requestedVideoInputDeviceId: deviceIds?.videoinput === "screen" ? "default" : deviceIds?.videoinput ?? "default"
              }
            })),
            requestMediaDeviceId: (deviceId, type) => set(({ __controls }) => ({
              __controls: {
                ...__controls,
                ...type === "videoinput" ? {
                  requestedVideoInputDeviceId: deviceId
                } : type === "audioinput" ? {
                  requestedAudioInputDeviceId: deviceId
                } : {}
              }
            })),
            setStatus: (status) => set(() => ({
              status
            })),
            setMediaDeviceIds: (newMediaDeviceIds) => set(({ mediaDeviceIds }) => ({
              mediaDeviceIds: {
                ...mediaDeviceIds,
                ...newMediaDeviceIds
              }
            })),
            updateDeviceList: (mediaDevices) => set(({ __controls }) => ({
              __controls: {
                ...__controls,
                mediaDevices
              }
            })),
            requestDeviceListInfo: () => set(({ __controls }) => ({
              __controls: {
                ...__controls,
                requestedUpdateDeviceListLastTime: Date.now()
              }
            })),
            toggleVideo: () => set(({ video, aria }) => ({
              video: !video,
              aria: {
                ...aria,
                videoTrigger: !video ? "Turn video off (v)" : "Turn video on (v)"
              }
            })),
            toggleAudio: () => set(({ audio, aria }) => ({
              audio: !audio,
              aria: {
                ...aria,
                audioTrigger: !audio ? "Turn audio off (space)" : "Turn audio on (space)"
              }
            })),
            toggleEnabled: () => set(({ enabled, aria }) => ({
              enabled: !enabled,
              aria: {
                ...aria,
                start: enabled ? "Start broadcasting (b)" : "Stop broadcasting (b)"
              }
            }))
          }
        }),
        {
          name: "livepeer-broadcast-controller",
          version: 1,
          // these values are persisted across broadcasts
          partialize: ({ audio, video, mediaDeviceIds }) => ({
            audio,
            video,
            mediaDeviceIds
          }),
          storage: createJSONStorage(() => storage)
        }
      )
    )
  );
  const destroy = store.persist.onFinishHydration(
    ({ mediaDeviceIds, audio, video }) => {
      store.getState().__controlsFunctions.setInitialState(mediaDeviceIds, audio, video);
    }
  );
  return { store, destroy };
};
var MEDIA_BROADCAST_INITIALIZED_ATTRIBUTE = "data-livepeer-broadcast-initialized";
var allKeyTriggers = [
  "KeyL",
  "KeyV",
  "KeyB",
  "Space",
  "KeyD",
  "KeyC",
  "KeyM"
];
var addBroadcastEventListeners = (element, store, mediaStore) => {
  const onKeyUp = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const code = e.code;
    if (allKeyTriggers.includes(code)) {
      if (code === "Space" || code === "KeyL") {
        store.getState().__controlsFunctions.toggleAudio();
      } else if (code === "KeyV") {
        store.getState().__controlsFunctions.toggleVideo();
      } else if (code === "KeyB") {
        store.getState().__controlsFunctions.toggleEnabled();
      } else if (code === "KeyD") {
        store.getState().__controlsFunctions.toggleDisplayMedia();
      } else if (code === "KeyC") {
        store.getState().__controlsFunctions.rotateVideoSource();
      } else if (code === "KeyM") {
        store.getState().__controlsFunctions.rotateAudioSource();
      }
    }
  };
  const onDeviceChange = () => {
    store.getState().__controlsFunctions.requestDeviceListInfo();
  };
  const mediaDevices = getMediaDevices();
  mediaDevices?.addEventListener?.("devicechange", onDeviceChange);
  const parentElementOrElement = element?.parentElement ?? element;
  if (element) {
    if (parentElementOrElement) {
      if (store.getState().__initialProps.hotkeys) {
        parentElementOrElement.addEventListener("keyup", onKeyUp);
        parentElementOrElement.setAttribute("tabindex", "0");
      }
    }
    element.setAttribute(MEDIA_BROADCAST_INITIALIZED_ATTRIBUTE, "true");
  }
  const removeEffectsFromStore = addEffectsToStore(element, store, mediaStore);
  const removeHydrationListener = store.persist.onFinishHydration(
    ({ mediaDeviceIds, audio, video }) => {
      store.getState().__controlsFunctions.setInitialState(mediaDeviceIds, audio, video);
    }
  );
  return {
    destroy: () => {
      removeHydrationListener?.();
      parentElementOrElement?.removeEventListener?.("keyup", onKeyUp);
      mediaDevices?.removeEventListener?.("devicechange", onDeviceChange);
      removeEffectsFromStore?.();
      element?.removeAttribute?.(MEDIA_BROADCAST_INITIALIZED_ATTRIBUTE);
    }
  };
};
var cleanupWhip = () => {
};
var cleanupMediaStream = () => {
};
var addEffectsToStore = (element, store, mediaStore) => {
  const destroyErrorCount = mediaStore.subscribe(
    ({ errorCount }) => errorCount,
    async (errorCount) => {
      if (errorCount > 0) {
        const delayTime = 500 * 2 ** (errorCount - 1);
        await delay(delayTime);
        store.getState().__controlsFunctions.requestForceRenegotiate();
      }
    }
  );
  const destroyMediaSyncMounted = mediaStore.subscribe(
    ({ mounted }) => mounted,
    async (mounted) => {
      store.setState({ mounted });
    }
  );
  const destroyMediaSyncError = mediaStore.subscribe(
    ({ error }) => error,
    async (error) => {
      if (error?.type === "permissions") {
        store.setState((state) => ({
          __controls: {
            ...state.__controls,
            requestedVideoInputDeviceId: state.mediaDeviceIds.videoinput
          }
        }));
      }
    }
  );
  const destroyPictureInPictureSupportedMonitor = store.subscribe(
    (state) => state.mediaStream,
    async () => {
      const isPipSupported = isPictureInPictureSupported(element);
      if (!isPipSupported) {
        mediaStore.setState((state) => ({
          __device: {
            ...state.__device,
            isPictureInPictureSupported: isPipSupported
          }
        }));
      }
    },
    {
      equalityFn: (a, b) => a?.id === b?.id
    }
  );
  const destroyWhip = store.subscribe(
    ({ enabled, ingestUrl, __controls, mounted }) => ({
      enabled,
      ingestUrl,
      requestedForceRenegotiateLastTime: __controls.requestedForceRenegotiateLastTime,
      mounted
    }),
    async ({ enabled, ingestUrl }) => {
      await cleanupWhip?.();
      if (!enabled) {
        return;
      }
      if (!ingestUrl) {
        warn3(
          "No ingest URL provided, cannot start stream. Please check the configuration passed to the Broadcast component."
        );
        return;
      }
      let unmounted = false;
      const onErrorComposed = (err) => {
        if (!unmounted) {
          mediaStore.getState().__controlsFunctions.setLive(false);
          mediaStore.getState().__controlsFunctions?.onError?.(err);
        }
      };
      store.getState().__controlsFunctions.setStatus("pending");
      const { destroy } = createNewWHIP({
        ingestUrl,
        element,
        callbacks: {
          onRTCPeerConnection: (peerConnection) => {
            store.getState().__controlsFunctions.setPeerConnection(peerConnection);
          },
          onConnected: () => {
            store.getState().__controlsFunctions.setStatus("live");
            mediaStore.getState().__controlsFunctions.onError(null);
          },
          onError: onErrorComposed
        },
        sdpTimeout: null
      });
      cleanupWhip = () => {
        unmounted = true;
        destroy?.();
        store.getState().__controlsFunctions.setStatus("idle");
      };
    },
    {
      equalityFn: (a, b) => a.requestedForceRenegotiateLastTime === b.requestedForceRenegotiateLastTime && a.ingestUrl === b.ingestUrl && a.enabled === b.enabled && a.mounted === b.mounted
    }
  );
  const destroyRequestUserMedia = store.subscribe(
    (state) => ({
      hydrated: state.hydrated,
      mounted: state.mounted,
      video: state.video,
      audio: state.audio,
      requestedAudioDeviceId: state.__controls.requestedAudioInputDeviceId,
      requestedVideoDeviceId: state.__controls.requestedVideoInputDeviceId,
      initialAudioConfig: state.__initialProps.audio,
      initialVideoConfig: state.__initialProps.video,
      previousMediaStream: state.mediaStream
    }),
    async ({
      hydrated,
      mounted,
      audio,
      video,
      requestedAudioDeviceId,
      requestedVideoDeviceId,
      previousMediaStream,
      initialAudioConfig,
      initialVideoConfig
    }) => {
      try {
        if (!mounted || !hydrated) {
          return;
        }
        if (!audio && !video) {
          warn3(
            "At least one of audio and video must be requested. Overriding video to be enabled so that `getUserMedia` can be requested."
          );
          store.setState({ video: true });
          video = true;
        }
        const audioConstraints = typeof initialAudioConfig !== "boolean" ? initialAudioConfig : null;
        const videoConstraints = typeof initialVideoConfig !== "boolean" ? initialVideoConfig : null;
        const stream = await (requestedVideoDeviceId === "screen" ? getDisplayMedia({
          // for now, only the microphone audio track is supported - we don't support multiple
          // discrete audio tracks
          audio: false,
          // we assume that if the user is requested to share screen, they want to enable video,
          // and we don't listen to the `video` enabled state
          //
          // we apply the video constraints to the video track
          video: videoConstraints ?? true
        }) : getUserMedia({
          audio: audio && requestedAudioDeviceId && requestedAudioDeviceId !== "default" ? {
            ...audioConstraints ? audioConstraints : {},
            deviceId: {
              // we pass ideal here, so we don't get overconstrained errors
              ideal: requestedAudioDeviceId
            }
          } : audio ? {
            ...audioConstraints ? audioConstraints : {}
          } : false,
          video: video && requestedVideoDeviceId && requestedVideoDeviceId !== "default" ? {
            ...videoConstraints ? videoConstraints : {},
            deviceId: {
              // we pass ideal here, so we don't get overconstrained errors
              ideal: requestedVideoDeviceId
            }
          } : video ? {
            ...videoConstraints ? videoConstraints : {}
          } : false
        }));
        if (stream) {
          const allAudioTracks = stream?.getAudioTracks() ?? [];
          const allVideoTracks = stream?.getVideoTracks() ?? [];
          const allAudioDeviceIds = allAudioTracks.map(
            (track) => track?.getSettings()?.deviceId
          );
          const allVideoDeviceIds = allVideoTracks.map(
            (track) => track?.getSettings()?.deviceId
          );
          const firstAudioDeviceId = allAudioDeviceIds?.[0] ?? null;
          const firstVideoDeviceId = allVideoDeviceIds?.[0] ?? null;
          store.getState().__controlsFunctions.setMediaDeviceIds({
            ...firstAudioDeviceId ? { audioinput: firstAudioDeviceId } : {},
            ...firstVideoDeviceId ? {
              videoinput: requestedVideoDeviceId === "screen" ? "screen" : firstVideoDeviceId
            } : {}
          });
          const mergedMediaStream = new MediaStream();
          const mergedAudioTrack = allAudioTracks?.[0] ?? previousMediaStream?.getAudioTracks?.()?.[0] ?? null;
          const mergedVideoTrack = allVideoTracks?.[0] ?? previousMediaStream?.getVideoTracks?.()?.[0] ?? null;
          if (mergedAudioTrack)
            mergedMediaStream.addTrack(mergedAudioTrack);
          if (mergedVideoTrack)
            mergedMediaStream.addTrack(mergedVideoTrack);
          store.getState().__controlsFunctions.updateMediaStream(mergedMediaStream);
        }
      } catch (e) {
        if (e?.name === "NotAllowedError") {
          mediaStore.getState().__controlsFunctions.onError(new Error(PERMISSIONS_ERROR_MESSAGE));
        } else {
          warn3(e?.message);
        }
      }
    },
    {
      equalityFn: (a, b) => a.hydrated === b.hydrated && a.mounted === b.mounted && a.requestedAudioDeviceId === b.requestedAudioDeviceId && a.requestedVideoDeviceId === b.requestedVideoDeviceId
    }
  );
  const destroyAudioVideoEnabled = store.subscribe(
    (state) => ({
      audio: state.audio,
      video: state.video,
      mediaStream: state.mediaStream
    }),
    async ({ audio, video, mediaStream }) => {
      if (mediaStream) {
        await setMediaStreamTracksStatus({
          mediaStream,
          enableAudio: Boolean(audio),
          enableVideo: Boolean(video)
        });
      }
    },
    {
      equalityFn: (a, b) => a.audio === b.audio && a.video === b.video && a.mediaStream?.id === b.mediaStream?.id
    }
  );
  const destroyPeerConnectionAndMediaStream = store.subscribe(
    ({ mediaStream, peerConnection }) => ({ mediaStream, peerConnection }),
    async ({ mediaStream, peerConnection }) => {
      if (!mediaStream || !peerConnection) {
        return;
      }
      await attachMediaStreamToPeerConnection({
        mediaStream,
        peerConnection
      });
    },
    {
      equalityFn: (a, b) => a.mediaStream?.id === b.mediaStream?.id && a.peerConnection === b.peerConnection
    }
  );
  const destroyMediaStream = store.subscribe(
    (state) => state.mediaStream,
    async (mediaStream) => {
      await cleanupMediaStream?.();
      if (mediaStream) {
        element.srcObject = mediaStream;
        const togglePlay = () => {
          mediaStore.getState().__controlsFunctions.togglePlay(true);
        };
        element.addEventListener("loadedmetadata", togglePlay);
        cleanupMediaStream = () => {
          element?.removeEventListener?.("loadedmetadata", togglePlay);
          element.srcObject = null;
        };
      } else {
        element.srcObject = null;
      }
    },
    {
      equalityFn: (a, b) => a?.id === b?.id
    }
  );
  const destroyUpdateDeviceList = store.subscribe(
    (state) => ({
      mounted: state.mounted,
      requestedUpdateDeviceListLastTime: state.__controls.requestedUpdateDeviceListLastTime
    }),
    async ({ mounted }) => {
      if (!mounted) {
        return;
      }
      const mediaDevices = getMediaDevices();
      const devices = await mediaDevices?.enumerateDevices();
      if (devices) {
        store.getState().__controlsFunctions.updateDeviceList(
          devices.filter((d) => d.deviceId)
        );
      }
    },
    {
      equalityFn: (a, b) => a.mounted === b.mounted && a.requestedUpdateDeviceListLastTime === b.requestedUpdateDeviceListLastTime
    }
  );
  const destroyMapDeviceListToFriendly = store.subscribe(
    (state) => ({
      mediaDeviceIds: state.mediaDeviceIds,
      mediaDevices: state.__controls.mediaDevices
    }),
    async ({ mediaDeviceIds, mediaDevices }) => {
      if (mediaDevices) {
        const extendedDevices = mediaDevices.filter((d) => d.deviceId).map((device, i) => ({
          deviceId: device.deviceId,
          kind: device.kind,
          groupId: device.groupId,
          label: device.label || null,
          friendlyName: device.label ?? `${device.kind === "audioinput" ? "Audio Source" : device.kind === "audiooutput" ? "Audio Output" : "Video Source"} ${i + 1} (${device.deviceId === "default" ? "default" : device.deviceId.slice(0, 6)})`
        }));
        const isScreenshare = mediaDeviceIds.videoinput === "screen";
        if (isScreenshare) {
          extendedDevices.push({
            deviceId: mediaDeviceIds.videoinput,
            label: "Screen share",
            groupId: "none",
            kind: "videoinput",
            friendlyName: "Screen share"
          });
        }
        store.setState({
          mediaDevices: extendedDevices
        });
      }
    },
    {
      equalityFn: (a, b) => a.mediaDeviceIds === b.mediaDeviceIds && a.mediaDevices === b.mediaDevices
    }
  );
  return () => {
    destroyAudioVideoEnabled?.();
    destroyErrorCount?.();
    destroyMapDeviceListToFriendly?.();
    destroyMediaStream?.();
    destroyMediaSyncError?.();
    destroyMediaSyncMounted?.();
    destroyPeerConnectionAndMediaStream?.();
    destroyPictureInPictureSupportedMonitor?.();
    destroyRequestUserMedia?.();
    destroyUpdateDeviceList?.();
    destroyWhip?.();
    cleanupWhip?.();
    cleanupMediaStream?.();
  };
};
export {
  addBroadcastEventListeners,
  createBroadcastStore,
  getBroadcastDeviceInfo
};
//# sourceMappingURL=index.js.map