"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/webrtc.ts
var webrtc_exports = {};
__export(webrtc_exports, {
  attachMediaStreamToPeerConnection: () => attachMediaStreamToPeerConnection,
  createNewWHEP: () => createNewWHEP,
  createNewWHIP: () => createNewWHIP,
  getDisplayMedia: () => getDisplayMedia,
  getMediaDevices: () => getMediaDevices,
  getUserMedia: () => getUserMedia
});
module.exports = __toCommonJS(webrtc_exports);

// src/webrtc/shared.ts
var import_errors = require("@livepeer/core/errors");

// src/media/utils.ts
var import_utils = require("@livepeer/core/utils");
var isClient = () => typeof window !== "undefined";

// src/webrtc/shared.ts
var getRTCPeerConnectionConstructor = () => {
  if (!isClient()) {
    return null;
  }
  return window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection || null;
};
function createPeerConnection(host) {
  const RTCPeerConnectionConstructor = getRTCPeerConnectionConstructor();
  if (RTCPeerConnectionConstructor) {
    const hostNoPort = host?.split(":")[0];
    const iceServers = host ? [
      {
        urls: `stun:${hostNoPort}`
      },
      {
        urls: `turn:${hostNoPort}`,
        username: "livepeer",
        credential: "livepeer"
      }
    ] : [];
    return new RTCPeerConnectionConstructor({ iceServers });
  }
  throw new Error("No RTCPeerConnection constructor found in this browser.");
}
var DEFAULT_TIMEOUT = 1e4;
async function negotiateConnectionWithClientOffer(peerConnection, endpoint, ofr, controller, accessControl, sdpTimeout) {
  if (peerConnection && endpoint && ofr) {
    const response = await postSDPOffer(
      endpoint,
      ofr.sdp,
      controller,
      accessControl,
      sdpTimeout
    );
    if (response.ok) {
      const answerSDP = await response.text();
      await peerConnection.setRemoteDescription(
        new RTCSessionDescription({ type: "answer", sdp: answerSDP })
      );
      const playheadUtc = response.headers.get("Playhead-Utc");
      return new Date(playheadUtc ?? /* @__PURE__ */ new Date());
    }
    if (response.status === 406) {
      throw new Error(import_errors.NOT_ACCEPTABLE_ERROR_MESSAGE);
    }
    const errorMessage = await response.text();
    throw new Error(errorMessage);
  }
  throw new Error("Peer connection not defined.");
}
async function constructClientOffer(peerConnection, endpoint) {
  if (peerConnection && endpoint) {
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    const ofr = await waitToCompleteICEGathering(peerConnection);
    if (!ofr) {
      throw Error("failed to gather ICE candidates for offer");
    }
    return ofr;
  }
  return null;
}
var playbackIdPattern = /([/+])([^/+?]+)$/;
var REPLACE_PLACEHOLDER = "PLAYBACK_ID";
var cachedRedirectUrl = null;
async function postSDPOffer(endpoint, data, controller, accessControl, sdpTimeout) {
  const id = setTimeout(
    () => controller.abort(),
    sdpTimeout ?? DEFAULT_TIMEOUT
  );
  const url = new URL(endpoint);
  const parsedMatches = url.pathname.match(playbackIdPattern);
  if (cachedRedirectUrl && parsedMatches?.[2]) {
    const clonedCachedUrl = new URL(cachedRedirectUrl);
    url.host = clonedCachedUrl.host;
    url.pathname = clonedCachedUrl.pathname.replace(
      REPLACE_PLACEHOLDER,
      parsedMatches[2]
    );
  }
  const response = await fetch(url.toString(), {
    method: "POST",
    mode: "cors",
    headers: {
      "content-type": "application/sdp",
      ...accessControl?.accessKey ? {
        "Livepeer-Access-Key": accessControl.accessKey
      } : {},
      ...accessControl?.jwt ? {
        "Livepeer-Jwt": accessControl.jwt
      } : {}
    },
    body: data,
    signal: controller.signal
  });
  clearTimeout(id);
  return response;
}
async function getRedirectUrl(endpoint, abortController, timeout) {
  try {
    if (cachedRedirectUrl) {
      const inputUrl = new URL(endpoint);
      inputUrl.host = cachedRedirectUrl.host;
      return inputUrl;
    }
    const id = setTimeout(
      () => abortController.abort(),
      timeout ?? DEFAULT_TIMEOUT
    );
    const response = await fetch(endpoint, {
      method: "HEAD",
      signal: abortController.signal
    });
    clearTimeout(id);
    const parsedUrl = new URL(response.url);
    if (parsedUrl) {
      const cachedUrl = new URL(parsedUrl);
      cachedUrl.pathname = cachedUrl.pathname.replace(
        playbackIdPattern,
        `$1${REPLACE_PLACEHOLDER}`
      );
      cachedRedirectUrl = cachedUrl;
    }
    return parsedUrl;
  } catch (e) {
    return null;
  }
}
async function waitToCompleteICEGathering(peerConnection) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(peerConnection.localDescription);
    }, 5e3);
    peerConnection.onicegatheringstatechange = (_ev) => {
      if (peerConnection.iceGatheringState === "complete") {
        resolve(peerConnection.localDescription);
      }
    };
  });
}

// src/webrtc/whep.ts
var VIDEO_WEBRTC_INITIALIZED_ATTRIBUTE = "data-livepeer-video-whep-initialized";
var createNewWHEP = ({
  source,
  element,
  callbacks,
  accessControl,
  sdpTimeout
}) => {
  if (element.getAttribute(VIDEO_WEBRTC_INITIALIZED_ATTRIBUTE) === "true") {
    return {
      destroy: () => {
      }
    };
  }
  element.setAttribute(VIDEO_WEBRTC_INITIALIZED_ATTRIBUTE, "true");
  let destroyed = false;
  const abortController = new AbortController();
  let peerConnection = null;
  const stream = new MediaStream();
  const errorComposed = (e) => {
    callbacks?.onError?.(e);
    if (element) {
      element.srcObject = null;
    }
  };
  getRedirectUrl(source, abortController, sdpTimeout).then((redirectUrl) => {
    if (destroyed || !redirectUrl) {
      return;
    }
    const redirectUrlString = redirectUrl.toString();
    callbacks?.onRedirect?.(redirectUrlString ?? null);
    peerConnection = createPeerConnection(redirectUrl.host);
    if (peerConnection) {
      peerConnection.addTransceiver("video", {
        direction: "recvonly"
      });
      peerConnection.addTransceiver("audio", {
        direction: "recvonly"
      });
      peerConnection.ontrack = async (event) => {
        try {
          if (stream) {
            const track = event.track;
            const currentTracks = stream.getTracks();
            const streamAlreadyHasVideoTrack = currentTracks.some(
              (track2) => track2.kind === "video"
            );
            const streamAlreadyHasAudioTrack = currentTracks.some(
              (track2) => track2.kind === "audio"
            );
            switch (track.kind) {
              case "video":
                if (streamAlreadyHasVideoTrack) {
                  break;
                }
                stream.addTrack(track);
                break;
              case "audio":
                if (streamAlreadyHasAudioTrack) {
                  break;
                }
                stream.addTrack(track);
                break;
              default:
                console.log(`received unknown track ${track}`);
            }
          }
        } catch (e) {
          errorComposed(e);
        }
      };
      peerConnection.addEventListener(
        "connectionstatechange",
        async (_ev) => {
          try {
            if (peerConnection?.connectionState === "failed") {
              throw new Error("Failed to connect to peer.");
            }
            if (peerConnection?.connectionState === "connected" && !element.srcObject) {
              element.srcObject = stream;
              callbacks?.onConnected?.();
            }
          } catch (e) {
            errorComposed(e);
          }
        }
      );
      peerConnection.addEventListener("negotiationneeded", async (_ev) => {
        try {
          const ofr = await constructClientOffer(
            peerConnection,
            redirectUrlString
          );
          const response = await negotiateConnectionWithClientOffer(
            peerConnection,
            source,
            ofr,
            abortController,
            accessControl,
            sdpTimeout
          );
          const currentDate = Date.now();
          if (response && currentDate) {
            callbacks?.onPlaybackOffsetUpdated?.(
              currentDate - response.getTime()
            );
          }
        } catch (e) {
          errorComposed(e);
        }
      });
    }
  }).catch((e) => errorComposed(e));
  return {
    destroy: () => {
      destroyed = true;
      abortController?.abort?.();
      if (element) {
        element.srcObject = null;
      }
      peerConnection?.close?.();
      element?.removeAttribute?.(VIDEO_WEBRTC_INITIALIZED_ATTRIBUTE);
    }
  };
};

// src/webrtc/whip.ts
var import_utils3 = require("@livepeer/core/utils");
var VIDEO_WEBRTC_INITIALIZED_ATTRIBUTE2 = "data-livepeer-video-whip-initialized";
var createNewWHIP = ({
  ingestUrl,
  element,
  callbacks,
  sdpTimeout
}) => {
  if (element.getAttribute(VIDEO_WEBRTC_INITIALIZED_ATTRIBUTE2) === "true") {
    return {
      destroy: () => {
      }
    };
  }
  element.setAttribute(VIDEO_WEBRTC_INITIALIZED_ATTRIBUTE2, "true");
  let destroyed = false;
  const abortController = new AbortController();
  let peerConnection = null;
  getRedirectUrl(ingestUrl, abortController, sdpTimeout).then((redirectUrl) => {
    if (destroyed || !redirectUrl) {
      return;
    }
    const redirectUrlString = redirectUrl.toString().replace("video+", "");
    peerConnection = createPeerConnection(redirectUrl.host);
    if (peerConnection) {
      peerConnection.addEventListener("negotiationneeded", async (_ev) => {
        try {
          const ofr = await constructClientOffer(
            peerConnection,
            redirectUrlString
          );
          await negotiateConnectionWithClientOffer(
            peerConnection,
            ingestUrl,
            ofr,
            abortController,
            {},
            sdpTimeout
          );
        } catch (e) {
          callbacks?.onError?.(e);
        }
      });
      peerConnection.addEventListener(
        "connectionstatechange",
        async (_ev) => {
          try {
            if (peerConnection?.connectionState === "failed") {
              callbacks?.onError?.(new Error("Failed to connect to peer."));
            }
            if (peerConnection?.connectionState === "connected") {
              callbacks?.onConnected?.();
            }
          } catch (e) {
            callbacks?.onError?.(e);
          }
        }
      );
      callbacks?.onRTCPeerConnection?.(peerConnection);
    } else {
      (0, import_utils3.warn)("Could not create peer connection.");
    }
  }).catch((e) => callbacks?.onError?.(e));
  return {
    destroy: () => {
      destroyed = true;
      abortController?.abort?.();
      peerConnection?.close?.();
      element?.removeAttribute?.(VIDEO_WEBRTC_INITIALIZED_ATTRIBUTE2);
    }
  };
};
var attachMediaStreamToPeerConnection = async ({
  mediaStream,
  peerConnection
}) => {
  const newVideoTrack = mediaStream?.getVideoTracks?.()?.[0] ?? null;
  const newAudioTrack = mediaStream?.getAudioTracks?.()?.[0] ?? null;
  const transceivers = peerConnection.getTransceivers();
  let videoTransceiver = transceivers.find(
    (t) => t.receiver.track.kind === "video"
  );
  let audioTransceiver = transceivers.find(
    (t) => t.receiver.track.kind === "audio"
  );
  if (newVideoTrack) {
    if (videoTransceiver) {
      await videoTransceiver.sender.replaceTrack(newVideoTrack);
    } else {
      videoTransceiver = await peerConnection.addTransceiver(newVideoTrack, {
        direction: "sendonly"
      });
    }
  }
  if (newAudioTrack) {
    if (audioTransceiver) {
      await audioTransceiver.sender.replaceTrack(newAudioTrack);
    } else {
      audioTransceiver = await peerConnection.addTransceiver(newAudioTrack, {
        direction: "sendonly"
      });
    }
  }
};
var getUserMedia = (constraints) => {
  if (typeof navigator === "undefined") {
    return null;
  }
  if (navigator?.mediaDevices?.getUserMedia) {
    return navigator.mediaDevices.getUserMedia(constraints);
  }
  if (navigator?.getUserMedia) {
    return navigator.getUserMedia(constraints);
  }
  if (navigator?.webkitGetUserMedia) {
    return navigator.webkitGetUserMedia(constraints);
  }
  if (navigator?.mozGetUserMedia) {
    return navigator.mozGetUserMedia(constraints);
  }
  if (navigator?.msGetUserMedia) {
    return navigator.msGetUserMedia(constraints);
  }
  (0, import_utils3.warn)(
    "getUserMedia is not supported in this environment. Check if you are in a secure (HTTPS) context - https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia"
  );
  return null;
};
var getMediaDevices = () => {
  if (typeof navigator === "undefined") {
    return null;
  }
  if (!navigator.mediaDevices) {
    (0, import_utils3.warn)(
      "mediaDevices was not found in this environment. Check if you are in a secure (HTTPS) context - https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia"
    );
    return null;
  }
  return navigator.mediaDevices;
};
var getDisplayMedia = (options) => {
  if (typeof navigator === "undefined") {
    (0, import_utils3.warn)("getDisplayMedia does not exist in this environment.");
    return null;
  }
  if (!navigator?.mediaDevices?.getDisplayMedia) {
    (0, import_utils3.warn)("getDisplayMedia does not exist in this environment.");
    return null;
  }
  return navigator.mediaDevices.getDisplayMedia(options);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  attachMediaStreamToPeerConnection,
  createNewWHEP,
  createNewWHIP,
  getDisplayMedia,
  getMediaDevices,
  getUserMedia
});
//# sourceMappingURL=index.cjs.map